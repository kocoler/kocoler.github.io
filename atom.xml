<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喫茶白玉楼</title>
  
  <subtitle>学习随笔、编程记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-14T17:08:45.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kocoler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go入门须知</title>
    <link href="http://yoursite.com/2020/11/15/%E5%85%A5%E9%97%A8GO%E9%A1%BB%E7%9F%A5/"/>
    <id>http://yoursite.com/2020/11/15/%E5%85%A5%E9%97%A8GO%E9%A1%BB%E7%9F%A5/</id>
    <published>2020-11-15T04:37:00.000Z</published>
    <updated>2020-11-14T17:08:45.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go入门须知"><a href="#Go入门须知" class="headerlink" title="Go入门须知"></a>Go入门须知</h1><blockquote><p>GOLANG, GOPATH, GOROOT ……</p></blockquote><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>后面可能会用到，用到的时候再回来看</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Environment_variable" target="_blank" rel="noopener">环境变量</a>（Environment Variable）</p><p>环境变量相当于给系统或用户应用程序设置的一些参数</p><p>作用于这个系统层面的，不拘束于某些应用程序等等</p><p>就比如我开机什么都不干Go就知道自己是装好的，知道哪里是GOPATH，大家都可以读取</p><p>如何写入？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">// <span class="built_in">export</span> xxx=xxx ...</span><br><span class="line">// <span class="built_in">export</span> 的意思就是将局部变量设置为环境变量</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line">// 检查是否成功</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$xxx</span></span><br><span class="line">// <span class="built_in">echo</span> 打印</span><br></pre></td></tr></table></figure><p>在别的教程看到的不同的文件（~/.profile, /etc/profile ……）有什么区别？</p><p><a href="https://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc" target="_blank" rel="noopener">如何选择放哪里</a></p><p><a href="https://superuser.com/questions/183870/difference-between-bashrc-and-bash-profile" target="_blank" rel="noopener">区别</a></p></li><li><p>PATH</p><p><code>PATH</code>: a list of directory paths. When the user types a command without providing the full path, this list is checked to see whether it contains a path that leads to the command.</p><p>简单来说，就是命令行去哪里找的问题</p><p>就像Go package要去GOPATH里找一样</p></li><li><p><a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/" target="_blank" rel="noopener">绝对路径/相对路径</a></p><p>绝对路径即/目录开始的一条完整路径。（绝对路径是唯一的）</p><p>相对路径即当前目录开始的</p></li><li><p>一些命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls // 当前目录下的所有文件</span><br><span class="line">$ go</span><br><span class="line">$ gofmt xxx // Go 的小工具，用来格式化代码风格、规范</span><br><span class="line">$ go env</span><br><span class="line">$ go run</span><br><span class="line">$ go build</span><br><span class="line">$ <span class="built_in">which</span> // 定位命令行文件位置</span><br><span class="line"></span><br><span class="line">// 带参数的</span><br><span class="line">$ go env -w // 设置Go环境变量</span><br><span class="line">$ go run -n // 打印编译期间所用到的其它命令，但是并不真正执行它们</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Go-官网"><a href="#Go-官网" class="headerlink" title="Go 官网"></a>Go 官网</h2><p><a href="https://golang.org/" target="_blank" rel="noopener">Golang官网</a> 是个需要翻墙才可以look的地方，不过问题不大</p><p>内含：</p><ul><li><p>Go 各版本的<a href="https://golang.org/doc/install" target="_blank" rel="noopener"><strong>安装</strong></a></p></li><li><p><a href="https://blog.golang.org/" target="_blank" rel="noopener">Go Blog</a></p><p> 可以获得一些官方的建议，最新的发展……</p></li><li><p><a href="https://golang.org/doc/" target="_blank" rel="noopener"><strong>Go 官方文档</strong></a></p><p>东西蛮多的，从Go的安装<del>到卸载</del>到各个阶段的教程都有了</p><p>最主要的是官方的</p><p>比较推荐其中的<strong><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective go</a></strong>，算是书写Go语言的规范，建议熟练运用Go之后学习</p></li><li><p><a href="https://play.golang.org/" target="_blank" rel="noopener">在线playground</a></p></li><li><p><a href="https://golang.org/project/" target="_blank" rel="noopener">更多关于go</a></p></li></ul><h3 id="Geting-started"><a href="#Geting-started" class="headerlink" title="Geting started"></a>Geting started</h3><p><img src="https://s3.ax1x.com/2020/11/15/DP7kNj.png" alt="image-20201113163139849"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vim 1.go // vim 1.c</span><br><span class="line"></span><br><span class="line">// coding......</span><br><span class="line"></span><br><span class="line">$ go build 1.go // gcc 1.c</span><br><span class="line">$ ./1 // ./a.out</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">$ go run 1.go // 目前推荐这种方式</span><br><span class="line">$ go install 1.go // 这个好玩</span><br><span class="line"></span><br><span class="line">// end</span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><blockquote><p>无论看哪本入门书籍，他们都会告诉你，Go很棒（当然所有语言的入门书籍都会这么说2333</p></blockquote><ul><li><p>Something about Go</p><p><strong>Less is more.</strong></p><p>C++功能太多了，Go作者也是C++程序员</p><p>讲个小故事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">谷歌大佬从事c++开发（分布式），某一天听说c++又要加新功能，内心疯狂吐槽后找了另外几个大佬，并表明觉得简化c++更棒</span><br><span class="line">大佬们一拍即合，他们决定开发一门新语言</span><br><span class="line">经过漫长岁月的发展，Go诞生了</span><br></pre></td></tr></table></figure><p><strong>基本的核心特性</strong></p><ul><li><p>简洁，开发效率高</p></li><li><p>内存管理</p></li><li><p><strong>并发编程</strong>，适合高并发</p></li><li><p>静态编译、强类型……</p></li><li><p>混合编程（cgo……）</p></li></ul></li><li><p>Golang is like C</p><p>看哪本书估计也都会提起Go是类C语言</p><p>在学习的时候可能会看到很多和C相似</p><p>这种（类C）语言通常是为某种具体的应用而仿照C语言（语法类似）开发的，所以学过C之后学Go会很快，<del>学过Cpp之后学Go会更快2333</del>。</p></li><li><p>A list of significant simplifications（重要的简化）</p><p>没有头文件</p><p>没有指针运算（no pointer arithmetic）</p><p>自建类型字符串，切片，哈希表（builtin string, slice, map）</p><p>内存0值初始化（memory is always zeroed）</p><p>多返回值</p><p>无循环依赖</p><p>数组越界检查</p><p>……</p></li><li><p><a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html" target="_blank" rel="noopener">more</a></p></li></ul><h4 id="GOENV"><a href="#GOENV" class="headerlink" title="GOENV"></a>GOENV</h4><p><img src="https://s3.ax1x.com/2020/11/15/DP7aDO.png" alt="image-20201113143044644"></p><p>都是<code>绝对路径</code>。</p><p>GO111MODULE：go mod，1.11版本后支持</p><p>GOARCH：环境架构</p><p><strong>GOBIN</strong></p><p>GOCACHE：缓存（go build）</p><p>GOHOSTOS：目标操作系统</p><p>GOPROXY：go代理</p><p><strong>GOPATH</strong></p><p><strong>GOROOT</strong></p><p>GOENV：Go环境配置，vim进去就可以看，一般通过 <code>go env -w xxx=xxx</code> 命令行设置的变量都存在里面，不用每次都切环境变量，不过优先度应该是在环境变量下<del>虽然我这台电脑就出现了奇奇怪怪的问题</del>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.10 darwin/amd64</span><br></pre></td></tr></table></figure><p><a href="https://golang.org/cmd/go/#hdr-Environment_variables" target="_blank" rel="noopener">more</a></p><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><h4 id="概念：GOROOT就是GO的安装目录"><a href="#概念：GOROOT就是GO的安装目录" class="headerlink" title="概念：GOROOT就是GO的安装目录"></a>概念：GOROOT就是GO的安装目录</h4><p>大家写这么久C，但是C都有什么应该还很模糊，但我们可以简单的看看Go都有什么</p><p>GOROOT里有什么：</p><p><img src="https://s3.ax1x.com/2020/11/15/DP7tv6.png" alt="image-20201113100054532"></p><ul><li><p>api</p><p>罗列了个版本Go api特性啥的，无所谓无所谓</p></li><li><p><strong>bin</strong></p><p>由go官方提供的一些工具的可执行文件</p><p>一般来说：自带的有go, gofmt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> go</span><br><span class="line">/usr/<span class="built_in">local</span>/go/bin/go</span><br></pre></td></tr></table></figure></li><li><p>doc</p><p>文档</p><p>示例程序，代码工具，本地文档等</p></li><li><p>version</p><p>版本号（顺便一提自己改是没有用的233）</p></li><li><p>pkg</p><p>存放编译后的包文件</p></li><li><p><strong>src</strong></p><p>标准库函数</p></li><li><p>favicon.ico</p><p>地鼠！</p></li></ul><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><h4 id="概念：可执行文件目录"><a href="#概念：可执行文件目录" class="headerlink" title="概念：可执行文件目录"></a>概念：可执行文件目录</h4><p>主要和 go install 相关，放各种go工具的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go install goexample</span><br><span class="line"></span><br><span class="line">$ goexample</span><br></pre></td></tr></table></figure><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>GOPATH为 Go 语言的工作区的<strong>集合（意味着可以有很多个）</strong>。工作区类似于工作目录。每个不同的目录之间用<code>：</code>分隔。</p><p>Go 1.11 版本之后引入 Go module，削弱GOPATH的约束</p><p>引自宋汝阳的良好的GOPATH结构（为了避免争议，暂且划分在启用go mod以前）：</p><p><img src="https://s3.ax1x.com/2020/11/15/DP7Ygx.png" alt="image-20201113144030923"></p><blockquote><p>这个是不是和GOROOT里很像？每个目录代表意思都差不多</p><p>那为什么我们要这么安排？</p></blockquote><p>GO Package 的引入规则</p><p>一般都是找两个地方：</p><p><code>$GOPATH/src/...</code> (from $GOPATH)</p><p><code>$GOROOT/src/...</code>  (from $GOROOT)</p><h3 id="Go-Package"><a href="#Go-Package" class="headerlink" title="Go Package"></a>Go Package</h3><p>我们之前在C语言中可能用到过的，<code>string.h</code>, <code>stdlib.h</code> 这些叫做库函数，在官方库函数之外还有各种各样的 包。</p><p>Go 程序是通过 package 来组织的。</p><p>例如：package 这一行告诉我们当前文件属于哪个包，而包名 main 则告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件。</p><blockquote><p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对<strong>独立性</strong>。这种<strong>模块化</strong>的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p><p>每个包一般都定义了一个<strong>不同的名字空间</strong>用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以避免在我们使用它们的时候减少和其它部分名字的冲突。</p><p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p><p>……</p></blockquote><h4 id="GO-官方包（标准库函数）"><a href="#GO-官方包（标准库函数）" class="headerlink" title="GO 官方包（标准库函数）"></a>GO 官方包（标准库函数）</h4><blockquote><p>$GOROOT/src</p></blockquote><p>学习他：<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">在线的，镜像的，官方的，被翻译过的</a></p><h4 id="GO-文件"><a href="#GO-文件" class="headerlink" title="GO 文件"></a>GO 文件</h4><p>GO 语言的源码文件主要分为几类：</p><ul><li><p><strong>命令源码文件</strong></p><p>命令源码文件总是作为可执行的程序的入口。</p><p>声明自己属于 main 代码包、 main 函数。</p><p>多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。</p><p><strong>main.go</strong></p></li><li><p><strong>库源码文件</strong></p><p>库源码文件一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）。</p></li><li><p><strong>测试源码文件</strong></p><p>测试源码文件主要用于对前两种源码文件中的程序实体的功能和性能进行测试。</p></li></ul><h4 id="一个包是如何组成、使用的"><a href="#一个包是如何组成、使用的" class="headerlink" title="一个包是如何组成、使用的"></a>一个包是如何组成、使用的</h4><blockquote><p>包是函数和数据的集合。</p><p>我们将会大量的用到各种包，各种途径的。</p></blockquote><ul><li><p>含有Go文件的目录……有可见性的东西（type, function）基本就能当作一个包使用了</p></li><li><p>用 package 关键字定义一个包。文件名不需要与包名一致，但是你的文件夹必须要与包名字一致，这个很重要，所以为了简单起见，名字都是一样的。</p><p>如果你定义好了这个包，那么就可以在外部引用他了</p></li><li><p>食用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                                                    */</span></span><br><span class="line"><span class="comment">/*    $GOPATH/src/github.com/kocoler/share/main.go    */</span></span><br><span class="line"><span class="comment">/*                                                    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  . <span class="string">"log"</span> <span class="comment">// 不推荐</span></span><br><span class="line">  </span><br><span class="line">_ <span class="string">"github.com/jinzhu/gorm/dialects/mysql"</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">"github.com/kocoler/share/example"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Muxi"</span>) <span class="comment">// fmt.Println()</span></span><br><span class="line">  Println(<span class="string">"Log Println"</span>) <span class="comment">// log.Println()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/*    $GOPATH/src/github.com/kocoler/share/example/example.go    */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"I'm initialzing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintA</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"example.PrintA() executed"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何找到你想用的包</p><ol><li>谷歌</li><li>Github</li><li><a href="https://pkg.go.dev/" target="_blank" rel="noopener">Go dev</a> 最近Go官方也很推这个</li></ol></li><li><p>放到GOPATH中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 比较笨拙的方法...</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com</span><br><span class="line">$ mkdir go-gorm</span><br><span class="line">$ <span class="built_in">cd</span> go-gorm</span><br><span class="line">$ git <span class="built_in">clone</span> github.com/go-gorm/gorm</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">$ go get -t https://github.com/go-gorm/gorm</span><br><span class="line"></span><br><span class="line">// 或者 go module, 交给后面的人讲了</span><br><span class="line">// 各有各的好处，不用纠结，直接auto，项目go mod，学习就off</span><br></pre></td></tr></table></figure></li><li><p>如何快速的上手/学会用一个包</p><ol><li><p>谷歌</p></li><li><p>Readme, go dev ……</p><p>Readme 重点关注quickly start</p></li></ol></li><li><p>不知道包引入路径？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go list</span><br><span class="line">github.com/kocoler/share/example</span><br><span class="line"></span><br><span class="line">$ go list <span class="built_in">log</span></span><br><span class="line"><span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="执行-Example-经历的一小小部分"><a href="#执行-Example-经历的一小小部分" class="headerlink" title="执行 Example 经历的一小小部分"></a>执行 Example 经历的一小小部分</h3><blockquote><p>如果有时间就小小说一下…..</p><p>无复杂东西</p><p>挺神奇的</p><p>加深理解233</p></blockquote><p>如果你记忆力好一点的话，可能知道C语言的编译过程，当然这无所谓</p><p>// 括号里是生成的</p><p>C/C++：预处理(.i)、编译(.s)、汇编(.o)、链接(.out)</p><p>Go：编译(.a)、链接(.out)</p><blockquote><p>.a文件是什么？</p><p>在Go中我们称.a文件为归档文件（也就是静态文件），简单来说就是放在pkg文件夹里编译好的包</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$  go run -n main.go</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$WORK</span>/b001/  <span class="comment"># 创建临时目录</span></span><br><span class="line"></span><br><span class="line">cat &gt;<span class="variable">$WORK</span>/b001/importcfg &lt;&lt; <span class="string">'EOF'</span> <span class="comment"># internal 查找依赖信息</span></span><br><span class="line"><span class="comment"># import config</span></span><br><span class="line">packagefile fmt=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/fmt.a</span><br><span class="line">packagefile github.com/jinzhu/gorm/dialects/mysql=/Users/mac/go/pkg/darwin_amd64/github.com/jinzhu/gorm/dialects/mysql.a</span><br><span class="line">packagefile github.com/kocoler/share/example=/Users/mac/Library/Caches/go-build/<span class="built_in">fc</span>/fc6b2deb1c0f91857e094ad17bbcd48cf4b2b84bf405710663a83dde72aeb6ad<span class="_">-d</span></span><br><span class="line">packagefile <span class="built_in">log</span>=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/log.a</span><br><span class="line">packagefile runtime=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/runtime.a</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /Users/mac/go/src/github.com/kocoler/share <span class="comment"># 执行源代码编译</span></span><br><span class="line">/usr/<span class="built_in">local</span>/go/pkg/tool/darwin_amd64/compile -o <span class="variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="string">"<span class="variable">$WORK</span>/b001=&gt;"</span> -p main -complete -buildid YWEJgSlrVcwt0-zEHmU8/YWEJgSlrVcwt0-zEHmU8 -dwarf=<span class="literal">false</span> -goversion go1.14.10 -D _/Users/mac/go/src/github.com/kocoler/share -importcfg <span class="variable">$WORK</span>/b001/importcfg -pack -c=4 ./main.go</span><br><span class="line">/usr/<span class="built_in">local</span>/go/pkg/tool/darwin_amd64/buildid -w <span class="variable">$WORK</span>/b001/_pkg_.a <span class="comment"># internal</span></span><br><span class="line"></span><br><span class="line">cat &gt;<span class="variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="string">'EOF'</span> <span class="comment"># internal 收集链接库文件</span></span><br><span class="line">packagefile <span class="built_in">command</span>-line-arguments=<span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line">packagefile fmt=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/fmt.a</span><br><span class="line">packagefile github.com/jinzhu/gorm/dialects/mysql=/Users/mac/go/pkg/darwin_amd64/github.com/jinzhu/gorm/dialects/mysql.a</span><br><span class="line">packagefile github.com/kocoler/share/example=/Users/mac/Library/Caches/go-build/<span class="built_in">fc</span>/fc6b2deb1c0f91857e094ad17bbcd48cf4b2b84bf405710663a83dde72aeb6ad<span class="_">-d</span></span><br><span class="line">packagefile <span class="built_in">log</span>=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/log.a</span><br><span class="line">......</span><br><span class="line">packagefile vendor/golang.org/x/sys/cpu=/usr/<span class="built_in">local</span>/go/pkg/darwin_amd64/vendor/golang.org/x/sys/cpu.a</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$WORK</span>/b001/exe/</span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line"><span class="comment"># 链接生成可执行文件</span></span><br><span class="line">/usr/<span class="built_in">local</span>/go/pkg/tool/darwin_amd64/link -o <span class="variable">$WORK</span>/b001/exe/main -importcfg <span class="variable">$WORK</span>/b001/importcfg.link -s -w -buildmode=exe -buildid=2g1FvKbI5O8czokn17YO/YWEJgSlrVcwt0-zEHmU8/YWEJgSlrVcwt0-zEHmU8/2g1FvKbI5O8czokn17YO -extld=clang <span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line"><span class="variable">$WORK</span>/b001/exe/main</span><br></pre></td></tr></table></figure><p>​    ……</p><hr><p>一些讨论</p><blockquote><p><a href="https://github.com/golang/go/issues/23439" target="_blank" rel="noopener">https://github.com/golang/go/issues/23439</a></p><p><a href="https://stackoverflow.com/questions/25216765/gobin-not-set-cannot-run-go-install" target="_blank" rel="noopener">https://stackoverflow.com/questions/25216765/gobin-not-set-cannot-run-go-install</a></p><p>……</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go入门须知&quot;&gt;&lt;a href=&quot;#Go入门须知&quot; class=&quot;headerlink&quot; title=&quot;Go入门须知&quot;&gt;&lt;/a&gt;Go入门须知&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;GOLANG, GOPATH, GOROOT ……&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>简述Elasticsearch 7.x</title>
    <link href="http://yoursite.com/2020/05/30/%E7%AE%80%E8%BF%B0Elasticsearch%207.x/"/>
    <id>http://yoursite.com/2020/05/30/%E7%AE%80%E8%BF%B0Elasticsearch%207.x/</id>
    <published>2020-05-30T13:48:39.000Z</published>
    <updated>2020-05-30T06:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述Elasticsearch-7-x"><a href="#简述Elasticsearch-7-x" class="headerlink" title="简述Elasticsearch 7.x"></a>简述Elasticsearch 7.x</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比</span><br></pre></td></tr></table></figure><h3 id="1-Luence"><a href="#1-Luence" class="headerlink" title="1. Luence"></a>1. Luence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎</span><br><span class="line">Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。</span><br></pre></td></tr></table></figure><p>简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。</p><p>更多有关Luence：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;tool.oschina.net&#x2F;apidocs&#x2F;apidoc?api&#x3D;lucene-3.6.0</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;lucene.apache.org&#x2F;core&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Luence的全文索引</strong></p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/Luence.webp" alt=""></p><h3 id="2-Solar-amp-ES"><a href="#2-Solar-amp-ES" class="headerlink" title="2. Solar &amp; ES"></a>2. Solar &amp; ES</h3><h4 id="2-1-Solar"><a href="#2-1-Solar" class="headerlink" title="2.1 Solar"></a>2.1 Solar</h4><p>Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。</p><p>在ES发布之前搜索引擎就是Solar的天下</p><p>Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。</p><h4 id="2-2-ES"><a href="#2-2-ES" class="headerlink" title="2.2 ES"></a>2.2 ES</h4><p>通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h4 id="2-3-比较"><a href="#2-3-比较" class="headerlink" title="2.3 比较"></a>2.3 比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.ES开箱即用</span><br><span class="line">2.ES自带分布式协调管理</span><br><span class="line">3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式</span><br><span class="line"></span><br><span class="line">4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用</span><br><span class="line">  ES建立索引快（即查询慢），即实时性查询快</span><br></pre></td></tr></table></figure><h3 id="3-ES-7-x"><a href="#3-ES-7-x" class="headerlink" title="3. ES 7.x"></a>3. ES 7.x</h3><h4 id="3-1-ES-的好朋友们"><a href="#3-1-ES-的好朋友们" class="headerlink" title="3.1 ES 的好朋友们"></a>3.1 ES 的好朋友们</h4><p>众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着</p><p><strong>ELK-Stack</strong>(elastic stack)</p><p>Logstash：数据收集，处理和储存</p><p>Elasticsearch：检索和分析</p><p>Kibana：可视化</p><p>Beats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 –&gt; Logstash （建立在名为libbeat的Go框架之上</p><ul><li><p><strong>elasticsearch head</strong></p><p>elasticsearch head 算是一个轻量级的管理器</p></li></ul><p>7.0版本支持SQL（X-Pack）</p><h4 id="3-2-ES-7-x"><a href="#3-2-ES-7-x" class="headerlink" title="3.2 ES 7.x"></a>3.2 ES 7.x</h4><p><strong>3.2.1 前情提要</strong>（上次所讲到的，和一些没有讲到的但是是基础的）</p><p>ES是一个分布式搜索引擎，底层使用Lucene来实现其核心搜索功能，所使用的是NoSQL（not only SQL)</p><p>核心：全文索引</p><p><strong>全文索引</strong></p><p>更适用于非结构化数据  （格式和长度不固定的数据），传统数据库查询效率很低</p><p>倒排索引</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%951.png" alt=""></p><p>倒排索引会先对文档进行分析将其拆分成单个Term, 并存储包含该Term的文档id</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%952.png" alt=""></p><p>这样的倒排索引建立起来会导致索引的大小迅速膨胀，对此引入了一个特殊的数据结构叫FST（有限状态转换器）<br>ES使用了索引帧（Frame of Reference）技术压缩posting list</p><p>然后是ES的基本概念：</p><ul><li><p>Index: 索引</p><p>集合，类比DB</p></li><li><p>Type: </p><p>“_doc”</p><p>最近版本取消自定义</p></li></ul><ul><li><p>Document: 文档</p><p>记录</p></li><li><p>Field：字段</p><p>某一属性</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">库（database）索引（index）表（table）类型（type）行（row）文档（doc）列（column）字段（field）</span><br></pre></td></tr></table></figure><p>  类型</p><p>  core datatypes: string:text/keyword numeric:long, integer……….</p><p>  complex datatypes</p><p>  gro datatypes</p><p>  specialised datatypes: ip, rank feature</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;7.7&#x2F;mapping-types.html</span><br></pre></td></tr></table></figure><ul><li><p>mapping(索引模板)：</p><p>两个创建途径：</p><p>a. 当放入的数据不属于当前Type中任何一个的时候会自动创建 </p><p>b.通过<code>settings</code> <code>mappings</code> 来创建</p><p>通过mapping和setting可以设置很多属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">store: 是否存储</span><br><span class="line">analyzer: 分词器，默认是standard analyzer</span><br><span class="line">boost: 增加该字段的权重</span><br><span class="line">format: 设置输出格式（日期）</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;7.7&#x2F;mapping-params.html</span><br></pre></td></tr></table></figure></li><li><p>聚合：</p><p>类比pipiline</p></li><li><p>refresh：</p><p>刷新时间间隔</p><p>default：1s</p></li><li><p>translog：</p><p>当一个文档写入Lucence后是存储在内存中的，即使执行了refresh操作仍然是在文件系统缓存中，如果此时服务器宕机，那么这部分数据将会丢失。为此ES增加了translog， 当进行文档写操作时会先将文档写入Lucene，然后写入一份到translog，写入translog是落盘的。可以设置成异步存储。</p></li><li><p>flush：</p><p>每30分钟或当translog达到一定大小，ES会触发一次flush操作，此时ES会先执行refresh操作将buffer中的数据生成segment，然后调用lucene的commit方法将所有内存中的segment fsync到磁盘。此时lucene中的数据就完成了持久化。</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/flush.png" alt=""></p></li><li><p>fliter:</p><p>过滤</p><p>filter语句采用了Roaring Bitmap技术来缓存搜索结果，保证高频filter查询速度的同时降低存储空间消耗。</p></li><li><p>score:</p><p>默认情况下，Elasticsearch按相关性得分对匹配的搜索结果进行排序，该得分衡量每个文档与查询的匹配程度。</p></li><li><p>分片与备份：</p><p>分布式设计：为了支持对海量数据的存储和查询，Elasticsearch引入分片的概念，一个索引被分成多个分片，每个分片可以有一个主分片和多个副本分片，每个分片副本都是一个具有完整功能的lucene实例，可以独立进行存储和搜索。分片可以分配在不同的节点上，同一个分片的不同副本不能分配在相同的节点上。</p><p>Elasticsearch的早期版本默认为每个索引创建五个分片。从7.0.0开始，默认值为每个索引一个分片。</p><p>在进行读写操作时，ES会先计算出文档要所在或要分配到的分片，再从集群元数据中找出对应主分片的位置</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%89%AF%E6%9C%AC.jpg" alt=""></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更多的基本概念：https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;7.7&#x2F;glossary.html</span><br></pre></td></tr></table></figure><h4 id="3-3-ES-使用"><a href="#3-3-ES-使用" class="headerlink" title="3.3 ES 使用"></a>3.3 ES 使用</h4><p><strong>3.3.1 插件</strong></p><p>ES插件有很多，这里只介绍一个。</p><p>更多的时候我们需要通过聚合不同的插件来达到我们的目的，这也是ES极其强大的原因之一</p><ul><li>ik</li><li>pinyin</li></ul><p>ik是一款用于es的中文分词器插件</p><p>pinyin是一款用于es拼音形式的插件</p><p><strong>3.3.2 Restful格式下的使用</strong></p><ul><li><p>写入</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1531723</span><br></pre></td></tr></table></figure></li><li><p>查询</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E6%9F%A5%E8%AF%A2.png" alt=""></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/s1/_search</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"query":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"match_all":</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#手动创建settings与mappings</span></span><br><span class="line"><span class="comment">#不可覆盖</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/s1/#_settings</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"settings":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"number_of_shards":</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"number_of_replicas":</span> <span class="number">0</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="attr">"mappings":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"properties":</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"first":</span> <span class="string">&#123;"type":</span> <span class="string">"text"</span><span class="string">,</span> <span class="attr">"analyzer":</span> <span class="string">"ik_max_word"</span><span class="string">&#125;,</span></span><br><span class="line">      <span class="attr">"last":</span> <span class="string">&#123;"type":</span> <span class="string">"text"</span><span class="string">,</span> <span class="attr">"store":</span> <span class="literal">false</span><span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#_bulk 批量操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义添加/修改</span></span><br><span class="line"><span class="string">PUT</span> <span class="string">/e1/word/1</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"first":</span> <span class="string">"wo"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"next":</span> <span class="string">"ww"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">POST</span> <span class="string">/e1/word/</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"f":</span> <span class="string">"q"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"n":</span> <span class="string">"w"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">PUT</span> <span class="string">/s1/_bulk</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"1"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"世界"</span><span class="string">,"last":</span> <span class="string">"中国"</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"2"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"华师"</span><span class="string">,"last":</span> <span class="string">"木犀"</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"3"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"我爱中国"</span><span class="string">,"last":</span> <span class="string">"中国"</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"4"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"世界"</span><span class="string">,"last":</span> <span class="string">"美国"</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"5"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"世界"</span><span class="string">,"last":</span> <span class="string">"英国"</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;"index":&#123;"_id":"6"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"first":</span> <span class="string">"我爱中国"</span><span class="string">,"last":</span> <span class="string">"中国"</span><span class="string">,"ex":"我"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取配置</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/e1/_settings</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/e2/_settings</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/e1/_mapping</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#所有的类型设置</span></span><br><span class="line"><span class="string">GET</span> <span class="string">_all/_settings</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/e1/word/2?_source=n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过_version和version_type=external 进行版本控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#基本查询</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/e1/_search?q=first:wo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ik 全文查询match</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/s1/_search</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"version":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"from":</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"size":</span> <span class="number">2</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"_source":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"includes":</span> <span class="string">"fir*"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"excludes":</span> <span class="string">"w"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="attr">"query":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"match":</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"first":</span> <span class="string">"我"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment">#query:"我"</span></span><br><span class="line"><span class="comment">#fields:["first","last"]</span></span><br><span class="line"><span class="comment">#range: "fields":"from":,"to":</span></span><br><span class="line"><span class="comment">#sort</span></span><br><span class="line"><span class="comment">#wildcard: 可用"*/?"</span></span><br><span class="line"><span class="comment">#fuzzy: 模糊查询</span></span><br><span class="line"><span class="comment">#filter: 过滤上下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ik + pinyin</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/test8/_settings</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/test8/_mapping</span></span><br><span class="line"></span><br><span class="line"><span class="string">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="string">"analyzer"</span><span class="string">:"pinyin",</span></span><br><span class="line">  <span class="string">"text"</span><span class="string">:"我爱中华人民共和国"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">PUT</span> <span class="string">/test8/_doc/3</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"content":</span> <span class="string">"我爱华师"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">PUT</span> <span class="string">/test8/_doc/4</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"content":</span> <span class="string">"中国武汉"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">PUT</span> <span class="string">/test8/_doc/5</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"content":</span> <span class="string">"武汉在中国"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">GET</span> <span class="string">/test8/_search</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"query":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"match":</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">"content":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"query":</span> <span class="string">"zg"</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何自制分析器：</span><br><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;7.7&#x2F;analysis-custom-analyzer.html</span><br></pre></td></tr></table></figure><h4 id="3-4-ES-与-Go"><a href="#3-4-ES-与-Go" class="headerlink" title="3.4 ES 与 Go"></a>3.4 ES 与 Go</h4><p>ES虽然很早就出现了，但是最先写Go语言使用ES的一些接口框架的并不是官方，所以事实上另一个第三方包更火一点（星星数），并且作者也在积极的维护，功能完备</p><p>这两个包分别是 <strong><a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">olivere/elastic</a></strong> 和 <strong><a href="https://github.com/elastic/go-elasticsearch" target="_blank" rel="noopener">elastic/go-elasticsearch</a></strong></p><p>这里主要介绍olivere/elastic这个第三方包具体使用情况和grom挺相似的</p><p>一些示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算了，直接看官方的吧：<a href="https://olivere.github.io/elastic/" target="_blank" rel="noopener">https://olivere.github.io/elastic/</a></p><p>参考链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;cn&#x2F;logstash</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;blueskyli&#x2F;p&#x2F;8326229.html</span><br><span class="line">https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1543565</span><br><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;137574234</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;LQBlog&#x2F;p&#x2F;10449637.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述Elasticsearch-7-x&quot;&gt;&lt;a href=&quot;#简述Elasticsearch-7-x&quot; class=&quot;headerlink&quot; title=&quot;简述Elasticsearch 7.x&quot;&gt;&lt;/a&gt;简述Elasticsearch 7.x&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
    
      <category term="ES" scheme="http://yoursite.com/tags/ES/"/>
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>简述几种常见的树</title>
    <link href="http://yoursite.com/2020/03/29/%E7%AE%80%E8%BF%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%91/"/>
    <id>http://yoursite.com/2020/03/29/%E7%AE%80%E8%BF%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%91/</id>
    <published>2020-03-29T13:48:39.000Z</published>
    <updated>2020-05-30T06:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述几种常见的树"><a href="#简述几种常见的树" class="headerlink" title="简述几种常见的树"></a>简述几种常见的树</h2><h3 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h3><blockquote><p>它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。</p></blockquote><ul><li>节点</li><li>子节点</li><li>父节点</li><li>根节点</li><li>节点的度：含有子树的个数</li><li>层</li><li>高度/深度</li><li>森林</li></ul><p>应用范围很广</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E6%A0%91.PNG" style="zoom:80%;" /><h3 id="2-树的几种常见类型"><a href="#2-树的几种常见类型" class="headerlink" title="2. 树的几种常见类型"></a>2. 树的几种常见类型</h3><ul><li><p>二叉树</p><ul><li><p>完全二叉树</p><ul><li>堆（优先队列的高效实现方式）<ul><li>霍夫曼树</li></ul></li></ul></li><li><p>二叉搜索树</p><ul><li><p>平衡二叉搜索树</p></li><li><p>红黑树</p></li></ul></li></ul></li><li><p>N叉树</p><ul><li>B树</li><li>B+树</li></ul></li><li><p>前缀树（ 字典树、Trie ）</p></li><li><p>后缀树</p></li></ul><h3 id="3-从最单纯的二叉树开始"><a href="#3-从最单纯的二叉树开始" class="headerlink" title="3. 从最单纯的二叉树开始"></a>3. 从最单纯的二叉树开始</h3><p>特点：有一个根节点，最多只有两个孩子（两棵子树），左孩子和右孩子，即有序的</p><p>主要算法：</p><ul><li>四种遍历方式（一般采用递归）：<ul><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li><li>层序遍历：左顾右盼</li></ul></li><li>增删查：BFS/DFS暴力，拼接</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    leftchild *treeNode</span><br><span class="line">    rightchild *treeNode</span><br><span class="line">    <span class="comment">//high int</span></span><br><span class="line">    <span class="comment">//leftSize int</span></span><br><span class="line">    <span class="comment">//other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要应用：表示结构层次与逻辑，三种遍历方式形成的前缀式、中缀式、后缀式可以表示运算和各种用途</p><p>表达式树：</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91.PNG" alt=""></p><p>那么，我们将这棵二叉树理想化一下：</p><p>假设这棵树经过了适当的调整，并放入实当的数据，他变满了</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>特点： 满的</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt=""></p><p>通过这次理想化，我们可以看到二叉树的结构很鲜明，有一定的可塑性，于是大佬们为这种优美的<del>麻烦的</del>树结构定义了几种特例：</p><p>首先是和满二叉树最接近的：</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><blockquote><p>对高度为h的满二叉树的元素，从第一层到最后一层，在每一次中从左至右，顺序编号，从 1 到 2^h-1 。假设从满二叉树中删除k个其编号为 2^h-i 元素， 1 &lt;= i &lt;= k &lt; 2^h ，所得到的二叉树被称为完全二叉树。</p></blockquote><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt=""></p><p>特点：</p><ul><li><p>建立在满二叉树的基础之上，除最后一层，都是满的，最后一层的元素从左至右排序，中间没有空缺。</p></li><li><p>一个元素和他的孩子有着很好的对应关系：例如父节点为 i/2 ， 2i&gt;n 时，无左孩子或左孩子为 2i ， 2i+1&gt;n 时，无右孩子或右孩子为 2i+1 </p></li></ul><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>特点：<br>它是一棵理想平衡的树，高度不高于logn</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%B9%B3%E8%A1%A1%E6%A0%91.PNG" style="zoom:80%;" /><hr><p>有了以上的基础，我们再来看二叉树历史上伟大的发明</p><h3 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h3><p>特点：</p><ul><li><p>利用二分思想，减少无关数据的遍历，增加检索速度</p></li><li><p>二叉树，左边的子节点小于当前节点的值，右边子节点大于当前节点的值</p><p>（即左边的节点永远小于根节点，有右边的节点永远大于根节点</p></li><li><p>对其做中序遍历，那么将会得到一个单调非降的结果</p></li></ul><p><strong>局部的顺序性 ———&gt; 全局的顺序性</strong></p><p>我们可以简单的把他看成二维list和vector(slice)  (sorted)的结合体</p><p>可排序的vector和有结点指向的list</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/BST.PNG" alt=""></p><p>那么我们来设想这样一个场景，比如所有的数都比第一个数大，这样这棵树就会极度右斜，即是一种最坏情况，此时这棵树退化为list</p><p>搜索：比较大小，逐层深入</p><p>我们可以看出树高对搜索的性能影响很大，然而完全满足logn的理想平衡的二叉树（满二叉树、完全二叉树）要求也很苛刻，实际中应用意义不大</p><p>于是，我们来引入一个适度平衡的思想：即保证树高在渐进意义上不超过logn</p><p>那么就有了二叉搜索树中的一种神奇的特例：<strong>平衡二叉搜索树(BBST)</strong></p><p>BBST树中的一种特例：AVL树（某些书上也将这两种树看作是一种</p><p>（但实际上不同的BBST树所采用的界定平衡的标准不同，重平衡的办法也不大相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AVLtreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    leftChild *AVLtreeNode</span><br><span class="line">    rightChild *AVLtreeNode</span><br><span class="line">    <span class="comment">//parent *AVLtreeNode</span></span><br><span class="line">    hight <span class="keyword">int</span> <span class="comment">//balance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/AVL%E6%A0%91.PNG" style="zoom:80%;" /><p>AVL树是<strong>自平衡</strong>的树。即在动态插入和删除的过程中始终能维护树的平衡性</p><p>主要算法：</p><ul><li>计算树高（计算平衡因子</li><li>单旋</li><li>双旋</li><li>增删查</li></ul><p>那么，这个时候问题又来啦，AVL树能保证insert为O(1)，但他的删除操作有可能到O(logn)的，单次动态调整后，全树的拓扑结构的大量变化是他的致命缺点</p><p>于是，就有了红黑树这种将动态调整控制在常数次的BBST</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>特点：</p><blockquote><p>树根必为黑色<br>外部节点必为黑色<br>除树根的内部节点若为红，则只能有黑孩子<br>外部节点到跟节点的途中黑节点数目相等</p></blockquote><p>相对于AVL树，红黑树的平衡条件并不是1，而是采用红黑颜色的方式，因此，他并不是追求严格的高度平衡，而是以此来换取极高的插入和删除的效率，相比AVL树，最突出的优点就是他的删除操作</p><p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E7%BA%A2%E9%BB%91%E6%A0%91.PNG" alt=""></p><p>如果我们进行lifting变换，那么可以看出，其实红黑树就是棵（2，4）树</p><p>而且事实也正是如此，我们可以简单的将红黑树理解为对AVL树和B树的巧妙综合运用<br>（这也是为什么大部分书或教程的顺序是二叉树–&gt;搜索树–&gt;AVL树–&gt;B树–&gt;红黑树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RBTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    colour <span class="keyword">bool</span></span><br><span class="line">    leftChild *RBTreeNode</span><br><span class="line">    rightChild *RBTreeNode</span><br><span class="line">    parent *RBTreeNode</span><br><span class="line">    hight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要算法：</p><ul><li>插入删除查找</li></ul><p>主要是分多种情况进行操作</p><p>红黑树和AVL树的单次操作时间都是很快的，但是，事实使用中我们有可能对单次的操作并不是那么感兴趣，而是对整个操作序列感兴趣呢？</p><h3 id="分裂树（伸展树、Splay-Tree）"><a href="#分裂树（伸展树、Splay-Tree）" class="headerlink" title="分裂树（伸展树、Splay Tree）"></a>分裂树（伸展树、Splay Tree）</h3><p>将查询较为频繁的数据不断上浮，节点并不记录平衡信息</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%88%86%E8%A3%82%E6%A0%91.PNG" style="zoom:80%;" /><p>优势普遍体现在当字典用的时候</p><p>主要算法：</p><ul><li>增删查：主要是分裂操作（分裂节点）</li></ul><h3 id="多叉树（N叉树）"><a href="#多叉树（N叉树）" class="headerlink" title="多叉树（N叉树）"></a>多叉树（N叉树）</h3><p>那么，将目光放在比二叉树更多分支的多叉树（当然，树并不是叉越多就越高级，虽然二叉树是多叉树的一种特例，但在<strong>某种</strong>情形下，二叉树具备描述多叉树的能力</p><p>我们先看一个多叉树的栗子：<code>tree</code></p><p>我们都知道，CPU运算速度是很快的，而我们一般存储数据的地方（HDD）是很慢的，于是我们引入了缓存来解决这个问题，然而，内存和外存之间的速度差异还是很大的，我们可以把将数据从内存和外存之间的读取和写入成为I/O的话，那么每次I/O的时间就会很长，而对于存放在内存中的，比较小的数据，前面提到的AVL和红黑树是可以应对的，但是面对大量的存在于外存的数据，这样就显的有些慢了</p><p>幸运的是我们还知道从外存中读取1000个数据和读取1个数据所需的时间是相同的。<br>（于是关于从外存中读取数据就是分页形式也就不那么难解释了<br>于是我们就希望某些储存结构即能像树那样简单明了，又不愿意在时间上有更多的花费，于是大佬们就很顺理成章的发明了B树这种数据结构</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树也称m阶平衡搜索树（m&gt;=2）</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/B%E6%A0%91.PNG" style="zoom: 67%;" /><p>与其他的平衡搜索树相比，最大的优点就是极大的缩减了树高，每一个节点都能一次性取出大量的数据来进行操纵，进而将I/O带来的时间损耗降到最低</p><blockquote><p>一个四层高，分支度为500的B树，可以支持存储最多256TB的数据。</p></blockquote><p>每一次取出一整个vector（slice）来进行操作</p><p>B树还有一个特点就是，他将数据都保存在叶子节点中，其他节点的只保存引用，通过关键字来排序</p><p>查找时一层层深入，直至找到或返回NULL</p><p>即节点中保存大量的关键字信息和分支</p><p>数据量在有限数量内越大优势越明显</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Btree <span class="keyword">struct</span> &#123;</span><br><span class="line">    parent *Btree</span><br><span class="line">    valueNum <span class="keyword">int</span></span><br><span class="line">    value [m]<span class="keyword">int</span></span><br><span class="line">    child [m+<span class="number">1</span>]*Btree <span class="comment">//多 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要算法：</p><ul><li>插入，删除，查找：分裂，合并，遍历</li></ul><p>然而，持久化存储还有那么一类独特的应用，他们对速度相应的需求也很高</p><p><strong>数据库</strong></p><p>那么为了满足数据库的需求，我们再来审视现有的树状结构</p><p>同时我们来设想一个主键递增的情况，</p><p>这个情况下红黑树和AVL树的查找效率都还是保持不错的状态的</p><p>但红黑树也是会倾斜的，导致该结构不断退化</p><p>AVL树的节点调整会很频繁，磁盘I/O次数过多</p><p>而B树所携带的数据又不够多（节点数据存储方式差异）</p><p>于是，携带更多数据的一种树状结构被大佬们研发出来了！（当然我不清楚他是不是为了这个研究出来的，而且B+树也有被应用于操作系统的文件系统</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/B%2B%E6%A0%91.PNG" style="zoom:80%;" /><p>区别：</p><ul><li>B+树内部结构中并没有指向关键字具体信息的指针 ——&gt;  容纳信息多 ——&gt; I/O次数少</li></ul><p>特点：</p><ul><li>B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。</li><li>B+树的叶子节点是真正数据存储的地方（B树普通节点中也有相关的信息）</li><li>B+树的叶子节点用了一个链表串联起来，便于范围查找。且链表本身就是有序的。</li><li>查询效率稳定，遍历效率高</li></ul><p>（当然不同的引擎的底层实现肯定是不同的，但大部分都是基于B+树的数据结构</p><p>当然，沿用树这种可以将时间复杂度大幅度降低的思想和简明的结构，还有其他若干种衍生的神奇的结构出现，有可能遇到的还有：</p><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><p>特点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较</p><p>应用：分词工具</p><p>举个最实际的栗子： <code>sego</code> </p><p>[sego][<a href="https://github.com/huichen/sego]" target="_blank" rel="noopener">https://github.com/huichen/sego]</a></p><blockquote><p>Go中文分词<br>词典用 <strong>双数组trie（Double-Array Trie）</strong>实现， 分词器算法为基于词频的最短路径加动态规划。<br>支持普通和搜索引擎两种分词模式，支持用户词典、词性标注，可运行JSON RPC服务。<br>分词速度单线程9MB/s，goroutines并发42MB/s（8核Macbook Pro）。</p></blockquote><p>这当中就提到了DAT</p><p>那么我们先来看一颗最基础的前缀树：</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%AD%97%E5%85%B8%E6%A0%91.png" style="zoom:65%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*TrieTreeNode</span><br><span class="line">    end <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以拿数组来实现（主要是记录的过程）</p><p>特点：</p><ul><li>利用字符串的公共前缀来减少查询时间，最大限度的减少无谓字符串的比较</li><li>插入和查询速度快（常数级别），典型的时间换空间思想</li></ul><p>那么每一个节点都分配一个数组/HashMap显的略有奢侈，而且每次查询都需要再对其进行查询，遍历</p><p>于是大佬们又想继续优化trie的查询性能，提出了基于数组的trie，包括4数组，3数组和双数组，其中双数组又恰巧是时间复杂度和空间复杂度最好的</p><p><strong>双数组trie</strong></p><p>既然是双数组trie那肯定就需要两个（一维）数组了</p><ul><li>base数组：表示状态 –&gt; index位移量</li><li>check数组：储存校验信息</li></ul><p>这两个数组是基于Trie构建的<br>简单的说就是把一个前缀树里所有的状态转移，存储到base数组中，并在check数组中存储对状态转移合法性的检验信息。</p><img src="https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%8F%8C%E6%95%B0%E7%BB%84Trie.PNG" style="zoom:75%;" /><p>这个实现（主要是构造）起来也有一定的难度（串），因此多作为已经处理好的<strong>缓存</strong>来使用，就比如sego也是这样的</p><p>那么日常应该碰不到其他的比较明显的树状结构了……</p><p>当然这里不涉及各种竞赛树：比如赢者树 败者树…</p><p>也不包括那些在某些情况下用树状结构尤其是优化后实现很方便/适合的某些算法：比如并查集…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述几种常见的树&quot;&gt;&lt;a href=&quot;#简述几种常见的树&quot; class=&quot;headerlink&quot; title=&quot;简述几种常见的树&quot;&gt;&lt;/a&gt;简述几种常见的树&lt;/h2&gt;&lt;h3 id=&quot;1-树&quot;&gt;&lt;a href=&quot;#1-树&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Golang 官方标准库学习</title>
    <link href="http://yoursite.com/2019/12/07/Golang%20%E5%AE%98%E6%96%B9%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/07/Golang%20%E5%AE%98%E6%96%B9%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-12-07T15:49:00.000Z</published>
    <updated>2020-05-30T06:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-官方标准库学习"><a href="#Golang-官方标准库学习" class="headerlink" title="Golang 官方标准库学习"></a>Golang 官方标准库学习</h1><p>本文主要介绍Go源码中带有的所有官方标准库，很基本<br>内容还比较少，有机会会继续更新</p><h4 id="什么是golang官方标准库"><a href="#什么是golang官方标准库" class="headerlink" title="什么是golang官方标准库"></a>什么是golang官方标准库</h4><ol><li><p>这些包一般储存在GOROOT路径下的src文件夹中，并且是以.go为后缀名的（有可能你会在pkg/中找到一些.a后缀的文件 <a href="https://www.solvusoft.com/zh-cn/file-extensions/file-extension-a" target="_blank" rel="noopener">拓展.a</a><br>例如用apt-get安装后在ubuntu下的路径：</p><p>/usr/lib/go-1.10/src</p></li></ol><ol start="2"><li>如何简便的学习/观察这些库<br> <a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Go语言中文网</a><br><a href="https://golang.google.cn/pkg/" target="_blank" rel="noopener">官方英文</a><br>（当然本地观看的办法也很多）</li></ol><h4 id="进入本体"><a href="#进入本体" class="headerlink" title="进入本体"></a>进入本体</h4><ol><li><strong>net</strong><br> 从我们比较熟悉的网络包入手<br> 这个包主要是与网络相关，算是Go标准库中比较大型（也比较常用的）包<br> 主要包含了一些底层的协议实现<br> net包提供的函数和类型可用于使用Unix域以及网络socket通信、TCP/IP和UDP编程。<br>  <strong><a href="https://studygolang.com/static/pkgdoc/pkg/net_http.htm" target="_blank" rel="noopener">net/http</a></strong><br> http主要包提供了HTTP客户端和服务端的实现。<br> 包括创建服务器，路由<br> http目录下其他的子库：<br> <strong><a href="https://studygolang.com/static/pkgdoc/pkg/net_http_cgi.htm" target="_blank" rel="noopener">net/http/cgi</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_cookiejar.htm" target="_blank" rel="noopener">net/http/cookiejar</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_fcgi.htm" target="_blank" rel="noopener">net/http/fcgi</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_httptest.htm" target="_blank" rel="noopener">net/http/httptest</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_httptrace.htm" target="_blank" rel="noopener">net/http/httptrace</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_httputil.htm" target="_blank" rel="noopener">net/http/httputil</a><br> <a href="https://studygolang.com/static/pkgdoc/pkg/net_http_pprof.htm" target="_blank" rel="noopener">net/http/pprof</a></strong></li></ol><p>​    <strong><a href="https://studygolang.com/static/pkgdoc/pkg/net_url.htm" target="_blank" rel="noopener">net/url</a></strong><br>​    主要与解析/处理URL有关，比如url字符串解析、编码<br>​    net目录下其他子库：<br>​    <strong><a href="https://studygolang.com/static/pkgdoc/pkg/net_mail.htm" target="_blank" rel="noopener">net/mail</a><br>​    <a href="https://studygolang.com/static/pkgdoc/pkg/net_rpc.htm" target="_blank" rel="noopener">net/rpc</a><br>​    <a href="https://studygolang.com/static/pkgdoc/pkg/net_rpc_jsonrpc.htm" target="_blank" rel="noopener">net/rpc/jsonrpc</a><br>​    <a href="https://studygolang.com/static/pkgdoc/pkg/net_smtp.htm" target="_blank" rel="noopener">net/smtp</a><br>​    <a href="https://studygolang.com/static/pkgdoc/pkg/net_textproto.htm" target="_blank" rel="noopener">net/textproto</a></strong></p><ol start="2"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/fmt.htm" target="_blank" rel="noopener">fmt</a></strong><br>从入门到弃坑，都会使用的fmt库<br>fmt库主要涉及go的格式化操作，并且主要是字符串的格式化<br>包含最常见的格式化输入输出到控制台，当作目标函数的参数等等（debug也比较建议用log<br>fmt并没有再延伸的标准库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/log.htm" target="_blank" rel="noopener">log</a></strong><br>实现简易/简单的日志服务，是并发安全的<br>（最主要的是还带时间哈哈哈哈<br>调用会打印每条日志信息的日期、时间，默认输出到标准错误。<br>Print系列函数包括控制台的打印（使用参考fmt包<br>Fatal系列函数会在写入日志信息后调用os.Exit(1)<br>Panic系列函数会在写入日志信息后panic<br>适合一般情况下日志的记录，适合一般情况下对错误的处理，适合一般情况下的debug<br>log目录下的子库：</p></li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/log_syslog.htm" target="_blank" rel="noopener">log/syslog</a></strong></p><ol start="4"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/sort.htm" target="_blank" rel="noopener">sort</a></strong><br>方便的排序函数，主要是排序各式各样切片类型<br>主流的排序算法：插入排序，堆排序，快排，归并排序都有实现<br>并且一次排序不一定只调用一种函数，只要实现了 sort.Interface 定义的三个方法：获取数据集合长度的 Len() 方法、比较两个元素大小的 Less() 方法和交换两个元素位置的 Swap() 方法，就可以顺利对数据集合进行排序。sort 包会根据实际数据自动选择高效的排序算法。<br>当然，不做更多的要求的调用也很方便<br>还有search功能，可以同时支持更神奇的操作<br>PS1：sort包对不同类型的实现好像略有不同<br>PS2：sort包好像普通的排序不是稳定的，为此有特别提供稳定的stable函数<br>个人觉得是可以深入了解的库<br>没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/strings.htm" target="_blank" rel="noopener">strings</a></strong><br>实现用于操作字符的简单函数，即主要包含针对字符串操作的函数<br>为某些较复杂（麻烦）日常还会经常用到的一些需求提供方便的实现<br>比如：字符串分割，字符串匹配系列，字符串读取以及字符串替换/修剪等等<br>PS1：<strong>Go 中字符串是不可变的</strong><br>这个包里还声明了两个跟io包关系密切的类型:Reader和Replacer<br>strings包没有字库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/io.htm" target="_blank" rel="noopener">io</a></strong><br><del>自然</del>的过渡到io包<br>这个包经常会根其他的包联动<br><del>谈到io，自然要谈到I/O</del></p></li></ol><blockquote><p>同时，这里补充以下对Go中I/O的一点简述：</p><ul><li>io 为 IO 原语（I/O primitives）提供基本的接口</li><li>io/ioutil 封装一些实用的 I/O 函数</li><li>fmt 实现格式化 I/O，类似 C 语言中的 printf 和 scanf</li><li>bufio 实现带缓冲I/O</li></ul></blockquote><p>io包中声明了两个很强大，很厉害的类型(接口）：Reader和Writer<br>（其实这个包声明了很多类型，都很强的<br>io包中提供了供日常使用的很多读写功能，对常用资源（内存，文件等等）的读写的接口实现，使得很多操作变得简便，灵活性高（包括但不限函数间）<br>PS1: 由于这些被接口包装的I/O原语是由不同的低级操作实现，因此，在另有声明之前不该假定它们的并行执行是安全的。<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/io_ioutil.htm" target="_blank" rel="noopener">io/ioutil</a></strong><br>这个包很实用，很实用，很方便，很方便<br>常用函数：</p><pre><code>func ReadAll(r io.Reader)([]byte,error）func ReadFile(filename string)([]byte,error)func WriteFile(filename string,data []byte,perm os.FileMode) error</code></pre><ol start="7"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/bytes.htm" target="_blank" rel="noopener">bytes</a></strong><br>这个包主要是和Go中的[]byte类型的处理有关<br>string,bytes 联系蛮紧密的<br>因此，bytes包中有很多和strings相仿的函数，一定程度上可以参考string包学习（但其实大概没这个必要<br>还有两个类型Reader和<strong>Buffer</strong><br>Buffer本身是一个缓存，没有底层数据，缓存的容量会根据需要自动调整</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/errors.htm" target="_blank" rel="noopener">errors</a></strong><br>非常短<br>包含了实现创建错误值的函数（不过常见的error类型并不是在这里声明的！<br>只是包含了对错误的简单处理，相对的，个性化处理变得简单<br>很短，目录下没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/encoding.htm" target="_blank" rel="noopener">encoding</a></strong></p><blockquote><p>encoding包定义了供其它包使用的可以将数据在字节水平和文本表示之间转换的接口。encoding/gob、encoding/json、encoding/xml三个包都会检查使用这些接口。因此，只要实现了这些接口一次，就可以在多个包里使用。标准包内建类型time.Time和net.IP都实现了这些接口。接口是成对的，分别产生和还原编码后的数据。</p></blockquote></li></ol><p>以上是引用的官网的解释<br>encoding包主要是关于常用的各种数据格式的转化操作，子库包括了json,xml,csv,binary等等的转化操作<br>（解析和转化功能还是很强的<br>涉及一些和数据类型相关的知识<br>当然不同的类型实现方法/接收类型也很不一样<br>encoding目录下的子库：<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_ascii85.htm" target="_blank" rel="noopener">encoding/ascii85</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_asn1.htm" target="_blank" rel="noopener">encoding/asn1</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_base32.htm" target="_blank" rel="noopener">encoding/base32</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_base64.htm" target="_blank" rel="noopener">encoding/base64</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_binary.htm" target="_blank" rel="noopener">encoding/binary</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_csv.htm" target="_blank" rel="noopener">encoding/csv</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_gob.htm" target="_blank" rel="noopener">encoding/gob</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_hex.htm" target="_blank" rel="noopener">encoding/hex</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_json.htm" target="_blank" rel="noopener">encoding/json</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_pem.htm" target="_blank" rel="noopener">encoding/pem</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/encoding_xml.htm" target="_blank" rel="noopener">encoding/xml</a></strong></p><ol start="10"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/time.htm" target="_blank" rel="noopener">time</a></strong><br>time包是关于日期时间的包，提供了时间的现实和计量等等的功能，是个强大的时间接口<br>PS：Go中采用公历，unix timestamp 是int64<br>time包目录下没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/runtime.htm" target="_blank" rel="noopener">runtime</a></strong><br>与Go运行时相关的实现，可以通过他的某些函数来控制goroutine<br>涉及计算机底层的堆栈<br>Go的并发很强有一部分原因与runtime的强大有关<br>runtime目录下的子库：</p></li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/runtime_cgo.htm" target="_blank" rel="noopener">runtime/cgo</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/runtime_debug.htm" target="_blank" rel="noopener">runtime/debug</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/runtime_pprof.htm" target="_blank" rel="noopener">runtime/pprof</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/runtime_race.htm" target="_blank" rel="noopener">runtime/race</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/runtime_trace.htm" target="_blank" rel="noopener">runtime/trace</a></strong></p><ol start="12"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/sync.htm" target="_blank" rel="noopener">sync</a></strong><br>谈起并发，sync包也很常用<br>sync包提供了基本的同步基元，但Go更推荐以channel的方式实现并发控制<br>常用的互斥锁：Mutex<br>线程控制：WaitGroup<br>还包含了一个Pool临时对象池<br>sync的原子操作包含在<strong><a href="https://studygolang.com/static/pkgdoc/pkg/sync_atomic.htm" target="_blank" rel="noopener">sync/atomic</a></strong>下</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/strconv.htm" target="_blank" rel="noopener">strconv</a>(string convert)</strong><br>字符串转化<br>strconv提供了关于字符串与其他类型转化的功能实现方法<br>整型：Itoa，Atio<br>浮点型：ParseFloat,FormatFloat<br>布尔型：ParseBool,FormatBool<br>有append系列<br>有Unicode和ASCII的操作<br>strconv目录下没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/unicode.htm" target="_blank" rel="noopener">unicode</a></strong><br>与unicode编码有关的基本函数<br>子库可以实现unicode（rune）与utf8（byte），utf16（int16）之间的转化</p></li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/unicode_utf16.htm" target="_blank" rel="noopener">unicode/utf16</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/unicode_utf8.htm" target="_blank" rel="noopener">unicode/utf8</a></strong></p><ol start="15"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/regexp.htm" target="_blank" rel="noopener">regexp</a></strong><br>正则表达式可能会迟到，但绝不会缺席！<br>regexp实现了正则表达式搜索<br>编译，匹配，搜索，替换<blockquote><p>本包的正则表达式保证搜索复杂度为O(n)<br><strong>很强</strong><br>Regexp类型提供了多达16个方法，用于匹配正则表达式并获取匹配的结果。</p></blockquote></li></ol><p>就正则吧，没啥可介绍的，基本每个语言都会提供的包，而且还就很麻烦qwq<br>还没翻译的子包：<strong><a href="https://studygolang.com/static/pkgdoc/pkg/regexp_syntax.htm" target="_blank" rel="noopener">regexp/syntax</a></strong></p><ol start="16"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/database_sql.htm" target="_blank" rel="noopener">database/sql</a></strong><br>实现了对SQL的大量操作<br>并且官网指出了<blockquote><p>使用sql包时必须注入（至少）一个数据库驱动。</p></blockquote></li></ol><p>例如</p><pre><code>_&quot;github.com/go-sql-driver/mysql&quot;</code></pre><p>这条语句将提供MySQL驱动。<br>具体的查询执行都是通过调用驱动实现的db接口中的方法<br>database/sql 提供的是抽象概念，和具体数据库无关，具体的数据库实现，有驱动来做，这样可以很方便的更换数据库。<br>子包<strong><a href="https://studygolang.com/static/pkgdoc/pkg/database_sql_driver.htm" target="_blank" rel="noopener">database/sql/driver</a></strong>定义了一些接口供数据库驱动实现</p><ol start="17"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/os.htm" target="_blank" rel="noopener">os</a></strong><br>os包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。<br>os包主要实现与操作系统相关的函数，并且是与平台无关的。<br>在 Go 中，文件描述符封装在 os.File 结构中，通过 File.Fd() 可以获得底层的文件描述符：fd。<br>例如：文件打开关闭，新建等等<br>子包：</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/os_user.htm" target="_blank" rel="noopener">os/user</a></strong><br>与系统用户相关的库，可用于获取登陆用户、所在祖等信息<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/os_signal.htm" target="_blank" rel="noopener">os/signal</a></strong><br>Unix-Like 的系统信号处理相关函数，Linux支持64中系统信号<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/os_exec.htm" target="_blank" rel="noopener">os/exec</a></strong><br>帮助我们实现了方便执行命令的能力</p><ol start="18"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/hash.htm" target="_blank" rel="noopener">hash</a></strong><br>hash包主要是提供了不同的hash算法<br>PS：md5 hash算法包含在crypto/hash中<br>子库主要提供了不同的循环冗余校验算法<br>日后加密时候会用到<br>一些子库：</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/hash_adler32.htm" target="_blank" rel="noopener">hash/adler32</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/hash_crc32.htm" target="_blank" rel="noopener">hash/crc32</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/hash_crc64.htm" target="_blank" rel="noopener">hash/crc64</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/hash_fnv.htm" target="_blank" rel="noopener">hash/fnv</a></strong></p><ol start="19"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/html.htm" target="_blank" rel="noopener">html</a></strong><br>html包提供了用于转义和解转义HTML文本的函数<br>主要是提供对html文本的处理<br>子包template提供了对html的模板渲染</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/html_template.htm" target="_blank" rel="noopener">html/template</a></strong></p><ol start="20"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/math.htm" target="_blank" rel="noopener">math</a></strong><br>math包提供了基本的数学处理<br>包括数学计算，数学常量<br>具体实现好像是通过大量的汇编代码实现<br>基本有需求的时候就可以直接用<br>子库</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/math_cmplx.htm" target="_blank" rel="noopener">math/cmplx</a></strong><br>支持复数操作<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/math_big.htm" target="_blank" rel="noopener">math/big</a></strong><br>支持高/多精度运算<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/math_rand.htm" target="_blank" rel="noopener">math/rand</a></strong><br><strong>随机生成数包</strong>这个还是很常用的（支持生成多种类型</p><blockquote><p>如果需要每次运行产生不同的序列，应使用Seed函数进行初始化。默认资源可以安全的用于多go程并发。</p></blockquote><p>这里引用一条官方的提示，并作一下解释：同一个程序多次调用rand函数只会生成同一个随机数，这个点需要注意一下</p><ol start="21"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/crypto.htm" target="_blank" rel="noopener">crypto</a></strong><br>crypto包提供了常用的加密算法<br>包含了常用的加密算法实现，比如最常见的公私钥加密，散列算法，各种签名算法等等<br>涉及算法层面很复杂，基本都是直接拿来用<br>基本都是提供与加密相关的函数，实际情况下，经常会于其他字符/数字处理包联动<br>大量的子库对应大量的加密算法</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_aes.htm" target="_blank" rel="noopener">crypto/aes</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_cipher.htm" target="_blank" rel="noopener">crypto/cipher</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_des.htm" target="_blank" rel="noopener">crypto/des</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_dsa.htm" target="_blank" rel="noopener">crypto/dsa</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_ecdsa.htm" target="_blank" rel="noopener">crypto/ecdsa</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_elliptic.htm" target="_blank" rel="noopener">crypto/elliptic</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_hmac.htm" target="_blank" rel="noopener">crypto/hmac</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_md5.htm" target="_blank" rel="noopener">crypto/md5</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_rand.htm" target="_blank" rel="noopener">crypto/rand</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_rc4.htm" target="_blank" rel="noopener">crypto/rc4</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_rsa.htm" target="_blank" rel="noopener">crypto/rsa</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_sha1.htm" target="_blank" rel="noopener">crypto/sha1</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_sha256.htm" target="_blank" rel="noopener">crypto/sha256</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_sha512.htm" target="_blank" rel="noopener">crypto/sha512</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_subtle.htm" target="_blank" rel="noopener">crypto/subtle</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_tls.htm" target="_blank" rel="noopener">crypto/tls</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_x509.htm" target="_blank" rel="noopener">crypto/x509</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/crypto_x509_pkix.htm" target="_blank" rel="noopener">crypto/x509/pkix</a></strong></p><ol start="22"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/syscall.htm" target="_blank" rel="noopener">syscall</a></strong><br>硬核系统层面调用<br>很复杂<br>实现应用层和操作底层的接口<strong>不同系统之间也存在着差异</strong><br>涉及架构、汇编<br>没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/bufio.htm" target="_blank" rel="noopener">bufio</a></strong></p><blockquote><p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。</p></blockquote></li></ol><p>通过io.Reader或io.Writer创建新的Reader或Writer实例<br>没有子库</p><ol start="24"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/builtin.htm" target="_blank" rel="noopener">builtin</a></strong><br>内部声明/定义了Go的内置类型、内置函数、内置变量</p><blockquote><p>builtin 包为Go的预声明标识符提供了文档。此处列出的条目其实并不在builtin包中，对它们的描述只是为了让 godoc 给该语言的特殊标识符提供文档。</p></blockquote><p>通过官网的声明来看，builtin只是个类似包含了说明文档的包，具体和Go的内部实现有关<br>builtin没有子包</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/expvar.htm" target="_blank" rel="noopener">expvar</a></strong><br>expvar提供了可以查询Go运行时的指标记录的接口<br>通过HTTP在/debug/vars位置以JSON格式导出了这些变量（很多）<br>个人认为使用范围可以比较广的一个包，但是<strong>这个包用的人很少…….</strong>非常少<br>运行时会自动注册<code>http://localhost:9090/debug/vars</code><br>(路由接口因程序而定，可以自定义<br>源码相对较少，没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/context.htm" target="_blank" rel="noopener">context</a></strong><br>Go上下文包<br>和Golang的并发有很大联系，可以帮助程序更好的控制并发，在不同的goroutine间实现安全的传递数据以及超时管理等<br>声明了重要的Context接口<br>主要应用在：控制goroutine的生命周期、使不同的Goroutine携带各自的value变量等<br>因为和并发关系很大，所以使用时要考虑的并发的知识要很全面<br>没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/flag.htm" target="_blank" rel="noopener">flag</a></strong><br>flag包用于命令行解析参数<br>可以很酷的帮助你实现命令行操作<br>例如<code>git commit -m</code><br>哈哈哈</p><blockquote><p>一般可以通过这个库来实现一些基本的操作，如果需要更复杂的命令行解析方式，可以用<a href="https://github.com/urfave/cli" target="_blank" rel="noopener">https://github.com/urfave/cli</a> 或者 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a>这两个非官方标准库</p></blockquote></li></ol><p>flag包没有子库</p><ol start="28"><li>go<br>go包是Go语言核心工具使用的包。<br>有兴趣可以直接看源码….这里就直接跳过啦</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/go_ast.htm" target="_blank" rel="noopener">go/ast</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_build.htm" target="_blank" rel="noopener">go/build</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_constant.htm" target="_blank" rel="noopener">go/constant</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_doc.htm" target="_blank" rel="noopener">go/doc</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_format.htm" target="_blank" rel="noopener">go/format</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_importer.htm" target="_blank" rel="noopener">go/importer</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_parser.htm" target="_blank" rel="noopener">go/parser</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_printer.htm" target="_blank" rel="noopener">go/printer</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_scanner.htm" target="_blank" rel="noopener">go/scanner</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_token.htm" target="_blank" rel="noopener">go/token</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/go_types.htm" target="_blank" rel="noopener">go/types</a></strong></p><ol start="29"><li>debug<br>debug包是Go语言中和调试有关的包<br>其中dwarf子包好像是主要与UNIX有关，包含很硬核的底层操作/信息，官网有pdf，有兴趣的可以下载下来看，很神奇哈哈哈，这里也是直接跳过</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/debug_dwarf.htm" target="_blank" rel="noopener">debug/dwarf</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/debug_elf.htm" target="_blank" rel="noopener">debug/elf</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/debug_gosym.htm" target="_blank" rel="noopener">debug/gosym</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/debug_macho.htm" target="_blank" rel="noopener">debug/macho</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/debug_pe.htm" target="_blank" rel="noopener">debug/pe</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/debug_plan9obj.htm" target="_blank" rel="noopener">debug/plan9obj</a></strong></p><ol start="30"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/path.htm" target="_blank" rel="noopener">path</a></strong><br>回归正常的Go标准库，path包实现了对路径处理（这里就是官网指的斜杠分隔的路径，即通过<em>/</em>分隔）常用与对文件路径、URL的处理<br>本身篇幅较短，大概是除了error包最简单易懂的了<br>主要就是方便的实现一系列与路径有关的操作<br>这个包似乎不适合Windows的磁盘路径处理（因为不同系统，路径表示方式有所不同<br>而他的子包<strong><a href="https://studygolang.com/static/pkgdoc/pkg/path_filepath.htm" target="_blank" rel="noopener">path/filepath</a></strong>实现了兼容的问题</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/plugin.htm" target="_blank" rel="noopener">plugin</a></strong><br>首先指出有的人有可能没有这个包…<br>因为这个包是Go1.8才被官方添加的包（可以通过<code>go version</code>查看当前版本然后去官网更新），目的是增加Go本身的动态库加载能力<br>目前只支持Linux和MacOS</p><blockquote><p>似乎使用不是那么方便，生成和使用库文件的环境有一定的要求</p></blockquote></li></ol><p>plugin包没有子包</p><ol start="32"><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/reflect.htm" target="_blank" rel="noopener">reflect</a></strong><br>（这个包其实位置应该放在前面一点的<br>主要包含与反射相关的函数，通过反射可以实现运行时的动态创建、修改变量、进行函数方法的调用等操作<br>有可能常用的两个方法：reflect.ValueOf,reflect.TypeOf<br>reflect包没有子库</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/testing.htm" target="_blank" rel="noopener">testing</a></strong><br>testing包提供了Go中自动化测试的相关实现<br>与<code>go test</code>命令配合使用</p><blockquote><p>常用的测试方法：单元测试，基准测试，子测试<br>Go推荐采用表格驱动的测试方式</p></blockquote></li></ol><p>子包：<strong><a href="https://studygolang.com/static/pkgdoc/pkg/testing_iotest.htm" target="_blank" rel="noopener">testing/iotest</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/testing_quick.htm" target="_blank" rel="noopener">testing/quick</a></strong></p><ol start="34"><li><p>text<br>text包主要是关于文本（<strong>不同于字符串</strong>）分析<br>词法分析：<strong><a href="https://studygolang.com/static/pkgdoc/pkg/text_scanner.htm" target="_blank" rel="noopener">text/scanner</a></strong><br>tab处理：<strong><a href="https://studygolang.com/static/pkgdoc/pkg/text_tabwriter.htm" target="_blank" rel="noopener">text/tabwriter</a></strong><br>模板引擎：<strong><a href="https://studygolang.com/static/pkgdoc/pkg/text_template.htm" target="_blank" rel="noopener">text/template</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/text_template_parse.htm" target="_blank" rel="noopener">text/template/parse</a></strong></p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/unsafe.htm" target="_blank" rel="noopener">unsafe</a></strong><br>unsafe包提供了一些跳过go语言类型安全限制的操作。<br>平时Go会限制一些可能导致程序运行出错的用法，通过unsafe可以突破Go的限制，包含不安全的操作<br>涉及底层编程<br>unsafe没有子包</p></li><li><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/image.htm" target="_blank" rel="noopener">image</a></strong><br>image实现了基本的2D图片库。</p></li></ol><p>**<a href="https://studygolang.com/static/pkgdoc/pkg/image_color.htm" target="_blank" rel="noopener">image/color</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/image_color_palette.htm" target="_blank" rel="noopener">image/color/palette</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/image_draw.htm" target="_blank" rel="noopener">image/draw</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/image_gif.htm" target="_blank" rel="noopener">image/gif</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/image_jpeg.htm" target="_blank" rel="noopener">image/jpeg</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/image_png.htm" target="_blank" rel="noopener">image/png</a></p><ol start="37"><li>archive<br>包含文件的归档</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/archive_tar.htm" target="_blank" rel="noopener">archive/tar</a></strong><br>压缩<strong><a href="https://studygolang.com/static/pkgdoc/pkg/archive_zip.htm" target="_blank" rel="noopener">archive/zip</a></strong></p><ol start="38"><li>compress<br>主要是与压缩有关的操作，包含常见的几种压缩格式bzip2、flate、gzip、lzw、zlib<br>有些操作要与tar联动使用</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/compress_bzip2.htm" target="_blank" rel="noopener">compress/bzip2</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/compress_flate.htm" target="_blank" rel="noopener">compress/flate</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/compress_gzip.htm" target="_blank" rel="noopener">compress/gzip</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/compress_lzw.htm" target="_blank" rel="noopener">compress/lzw</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/compress_zlib.htm" target="_blank" rel="noopener">compress/zlib</a></strong></p><ol start="39"><li><strong><a href="https://studygolang.com/static/pkgdoc/pkg/mime.htm" target="_blank" rel="noopener">mime</a></strong><br><a href="[https://baike.baidu.com/item/MIME/2900607?fr=aladdin](https://baike.baidu.com/item/MIME/2900607?fr=aladdin)">MIME</a>(Multipurpose Internet Mail Extensions)多用途互联网邮箱扩展类型<br>本包实现了一些和MIME有关的功能</li></ol><p><strong><a href="https://studygolang.com/static/pkgdoc/pkg/mime_multipart.htm" target="_blank" rel="noopener">mime/multipart</a><br><a href="https://studygolang.com/static/pkgdoc/pkg/mime_quotedprintable.htm" target="_blank" rel="noopener">mime/quotedprintable</a></strong></p><ol start="40"><li>index<br>index下只有一个子包，后缀数组<blockquote><p>suffixarrayb包通过使用内存中的后缀树实现了对数级时间消耗的子字符串搜索。</p></blockquote></li></ol><p>即将子字符串的查询时间复杂度下降到了logn<br>算是个算法包<br><strong><a href="https://studygolang.com/static/pkgdoc/pkg/index_suffixarray.htm" target="_blank" rel="noopener">index/suffixarray</a></strong></p><ol start="41"><li>container<br>（这个涉及数据结构，放在最后来写！！！<br>数组、切片、映射–&gt;内置数据结构<br>container中还包含了很多数据结构<br>堆<strong><a href="https://studygolang.com/static/pkgdoc/pkg/container_heap.htm" target="_blank" rel="noopener">container/heap</a></strong><br>双向链表<strong><a href="https://studygolang.com/static/pkgdoc/pkg/container_list.htm" target="_blank" rel="noopener">container/list</a></strong><br>环链<strong><a href="https://studygolang.com/static/pkgdoc/pkg/container_ring.htm" target="_blank" rel="noopener">container/ring</a></strong><br>具体的使用看源码就可以啦，平时使用也没有特别多的操作</li></ol><p>顺便一提，以上的标准库有一部分是依赖第三方包vender的，这个也是官方所开发</p><p>除了源码中带有的这些标准库，官方还在<a href="[https://github.com/golang](https://github.com/golang)">Github</a>上提供了很多包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Golang-官方标准库学习&quot;&gt;&lt;a href=&quot;#Golang-官方标准库学习&quot; class=&quot;headerlink&quot; title=&quot;Golang 官方标准库学习&quot;&gt;&lt;/a&gt;Golang 官方标准库学习&lt;/h1&gt;&lt;p&gt;本文主要介绍Go源码中带有的所有官方标准库，
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
</feed>
