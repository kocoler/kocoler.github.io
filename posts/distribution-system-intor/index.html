<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>浅谈分布式 | kocoler's blog</title>
<meta name=keywords content>
<meta name=description content="本文主要科普一下当前比较热门的分布式 主要涉及 分布式基本概念，共识性算法 其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~ 和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？ 虽然我不这么觉得，但是考虑分布式是有必要的 hhh
 分布式 Why we need distribution? (drivens) 开始之前我们先来讨论一下我们为什么分布式
 分享结束之后再看一遍这些问题
   性能 如何做到简单的增加服务器就使性能增强（像 GFS 的假设） 这时候我们需要设计一个架构来将这种能力推进下去
  容错 比如你的两台服务器，挂了一台 如何做到继续可用（当然故障多了就不能用了） 1000台呢（会被无限放大）
  物理分布 地球这么大，你的数据中心一定会分布到不同的地方
  安全性 你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响
  Distribution  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
 其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作
但是我们需要很多额外的策略
因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的
&mldr;
这些都要考虑到一个分布式系统的设计上
一些概念与指标  一致性 这个大概就是最重要的了，分布式系统的行为要表现出一致性  强一致性 就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。 弱一致性 弱一致性其实是很拥有的 比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）   可用性  在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。">
<meta name=author content>
<link rel=canonical href=https://kocoler.github.io/posts/distribution-system-intor/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kocoler.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://kocoler.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://kocoler.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://kocoler.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://kocoler.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="浅谈分布式">
<meta property="og:description" content="本文主要科普一下当前比较热门的分布式 主要涉及 分布式基本概念，共识性算法 其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~ 和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？ 虽然我不这么觉得，但是考虑分布式是有必要的 hhh
 分布式 Why we need distribution? (drivens) 开始之前我们先来讨论一下我们为什么分布式
 分享结束之后再看一遍这些问题
   性能 如何做到简单的增加服务器就使性能增强（像 GFS 的假设） 这时候我们需要设计一个架构来将这种能力推进下去
  容错 比如你的两台服务器，挂了一台 如何做到继续可用（当然故障多了就不能用了） 1000台呢（会被无限放大）
  物理分布 地球这么大，你的数据中心一定会分布到不同的地方
  安全性 你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响
  Distribution  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
 其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作
但是我们需要很多额外的策略
因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的
&mldr;
这些都要考虑到一个分布式系统的设计上
一些概念与指标  一致性 这个大概就是最重要的了，分布式系统的行为要表现出一致性  强一致性 就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。 弱一致性 弱一致性其实是很拥有的 比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）   可用性  在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://kocoler.github.io/posts/distribution-system-intor/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-07T21:48:39+00:00">
<meta property="article:modified_time" content="2021-10-07T21:48:39+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="浅谈分布式">
<meta name=twitter:description content="本文主要科普一下当前比较热门的分布式 主要涉及 分布式基本概念，共识性算法 其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~ 和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？ 虽然我不这么觉得，但是考虑分布式是有必要的 hhh
 分布式 Why we need distribution? (drivens) 开始之前我们先来讨论一下我们为什么分布式
 分享结束之后再看一遍这些问题
   性能 如何做到简单的增加服务器就使性能增强（像 GFS 的假设） 这时候我们需要设计一个架构来将这种能力推进下去
  容错 比如你的两台服务器，挂了一台 如何做到继续可用（当然故障多了就不能用了） 1000台呢（会被无限放大）
  物理分布 地球这么大，你的数据中心一定会分布到不同的地方
  安全性 你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响
  Distribution  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
 其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作
但是我们需要很多额外的策略
因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的
&mldr;
这些都要考虑到一个分布式系统的设计上
一些概念与指标  一致性 这个大概就是最重要的了，分布式系统的行为要表现出一致性  强一致性 就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。 弱一致性 弱一致性其实是很拥有的 比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）   可用性  在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kocoler.github.io/posts/"},{"@type":"ListItem","position":3,"name":"浅谈分布式","item":"https://kocoler.github.io/posts/distribution-system-intor/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浅谈分布式","name":"浅谈分布式","description":"本文主要科普一下当前比较热门的分布式 主要涉及 分布式基本概念，共识性算法 其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~ 和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？ 虽然我不这么觉得，但是考虑分布式是有必要的 hhh\n 分布式 Why we need distribution? (drivens) 开始之前我们先来讨论一下我们为什么分布式\n 分享结束之后再看一遍这些问题\n   性能 如何做到简单的增加服务器就使性能增强（像 GFS 的假设） 这时候我们需要设计一个架构来将这种能力推进下去\n  容错 比如你的两台服务器，挂了一台 如何做到继续可用（当然故障多了就不能用了） 1000台呢（会被无限放大）\n  物理分布 地球这么大，你的数据中心一定会分布到不同的地方\n  安全性 你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响\n  Distribution  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。\n 其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作\n但是我们需要很多额外的策略\n因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的\n\u0026hellip;\n这些都要考虑到一个分布式系统的设计上\n一些概念与指标  一致性 这个大概就是最重要的了，分布式系统的行为要表现出一致性  强一致性 就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。 弱一致性 弱一致性其实是很拥有的 比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）   可用性  在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。","keywords":[],"articleBody":" 本文主要科普一下当前比较热门的分布式 主要涉及 分布式基本概念，共识性算法 其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~ 和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？ 虽然我不这么觉得，但是考虑分布式是有必要的 hhh\n 分布式 Why we need distribution? (drivens) 开始之前我们先来讨论一下我们为什么分布式\n 分享结束之后再看一遍这些问题\n   性能 如何做到简单的增加服务器就使性能增强（像 GFS 的假设） 这时候我们需要设计一个架构来将这种能力推进下去\n  容错 比如你的两台服务器，挂了一台 如何做到继续可用（当然故障多了就不能用了） 1000台呢（会被无限放大）\n  物理分布 地球这么大，你的数据中心一定会分布到不同的地方\n  安全性 你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响\n  Distribution  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。\n 其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作\n但是我们需要很多额外的策略\n因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的\n…\n这些都要考虑到一个分布式系统的设计上\n一些概念与指标  一致性 这个大概就是最重要的了，分布式系统的行为要表现出一致性  强一致性 就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。 弱一致性 弱一致性其实是很拥有的 比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）   可用性  在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。\n  容错 自恢复 一个节点 recover 之后需要自恢复，   拓展性（性能） 就是上面说的，一样  指标\n  CAP 我们会更倾向于用 CAP 去划分一个分布式系统\n CAP 问题就是在出现分区问题的时候，是选择一致性还是可用性\n   一致性 同上\n  可用性 可用性一般有两个意义：\n 一个是普遍意义上的可用性，即容错和自恢复 另外一个是指对于每一次请求，都能够得到一个及时的、非错的响应，但是其实是不保证请求的结果是基于最新写入的数据。 CAP 理论指的是后一个，这也是为什么大部分分布式系统都是 CP 或者 AP   但其实 DDIA 中并不建议使用这玩意，但是现在大家说的还都是这个吧 hhhh 据说更精确的是 Consistency, Availability, and Convergence https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2036.pdf 但是咱也没看这篇呢，咱也不细说\n   分区容错性 基本指的是网络层面被划成若干个区情况下的容错性 为了避免混乱，说明一下其实这个玩意，就是容错，我们一般不会把他与正常的故障分开讨论，但是这里是 CAP 的 P\n  这个 CAP 其实也经过了漫长的演变\n ch: https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/ ori: https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/\n   FLP FLP 不可能原理\n 《Impossibility of Distributed Consensus with One Faulty Process》指出：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法\n 注意这里是异步的（这个其实在这次分享里不是很重要，在这里我们主要讨论同步调用，但是是分布式基本概念）\n  BASE BASE 理论主要是针对分布式场景下数据库 应用可以采用适合的方式达到最终一致性（Eventual Consitency）。\n 基本可用 允许损失部分可用性，即保证核心可用。 降级服务 软状态 允许中间状态 扩大来说就是允许副本之间时延 最终一致性 经过一段时间一定是一致的状态    很简单很简单，我们看看共识性算法，就流程来说也很简单~\n共识性算法 共识性算法算是分布式中最重要的一部分，在这一部分，我们可以对上面很多挑战做出解答 当我们讨论分布式的时候，应该把他和共识性算法分开来看待 当然他也很复杂（实现层面） 这里就是简单的让大家看一下他们是如何设计的（流程上） 当然不会涉及到太多的具体的 specs\n 通常只在每个分区内维持顺序，这意味着它们不能提供跨分区的一致性保证（例如，一致性快照，外键引用）。 跨所有分区的全序是可能的，但需要额外的协调\n  主要是 Paxos 和 Raft，其他我能听到的 VSR 和 Zab\n (Basic-)Paxos 我感觉时间可能会有点长，而且会和 Raft 搞混？所以还是简洁一下就略过吧 hhh 反正绝对没人会让你实现这个\n角色：\n client 客户端 acceptor/voters 决议 proposer 提议 learner 就是记录的  这个玩意主要分为两个阶段，一个是准备决议，一个是批准\nClient Proposer Acceptor Learner | | | | | | | X--------| | | | | | Request | X---------|-|-| | | Prepare(1) | ||-|-| | | Accept!(1,V) | ||-| Accepted(1,V) |但是这个其实有个缺陷，就是作为理论研究挺好的，但是实际场景就有点尴尬（流量过多），所以有了 Mutil-Paxos。\nRaft （其实这个才是最初分享的重点，但是我觉得还是分享一个分布式的思想比较有意义，Raft 学完就忘）\n基本就是解析 raft-extended c1 - c5(c7) 不，我不配，而且不太适合做分享，太细致了\n这个出现就是说，因为 Paxos 太难懂了 就但是这个其实也没那么简单\n他主要分为几个部分：\n Leader 选举（leader election） 随机时间 日志（log replication） 安全（safety） 这里的安全主要是指如何安全的保证日志的一致性  这里我们只介绍一下 Leader 选举和最基本的如何保证一致性（没那么多复杂状态）好了\n http://thesecretlivesofdata.com/raft/#replication\n 现实中是如何设计分布式的 这个涉及的太多了，等我学完再说吧\n就大概那样吧，不同策略结合，现场说吧\n数据中心，分片（Map-Reduce）\n不断屏蔽下一层设计（以 kv-db 为例：client - data-center(k8s/swarm multi-master) - db-nodes(raft …) - storage(gfs/hdfs/megastore …) - … ）\n当然不同的设计是不一样的\n多主之间的一致性： 很复杂咯，但是主要问题就是： 复制 + 解决冲突\n拓扑复制：\n主要就是处理写入冲突，毕竟是给大家分享，这里举个大家都听过的最简单的方法：UUID 最后写入胜利(LWW) 其他：Conflict-free replicated datatypes、Mergeable persistent data structures、Operational transformation 都需要具体实现\n你们可能会见到的：两阶段提交（2PC）\n当然这些还只是入门，分布式坑很大，很值得思考，很值得去寻找解决方案\nrefs:\n https://en.wikipedia.org/wiki/Paxos_(computer_science) https://stackoverflow.com/questions/25230005/leader-address-location-in-raft https://vonng.gitbooks.io/ddia-cn\n  Chubby: https://medium.com/coinmonks/chubby-a-centralized-lock-service-for-distributed-applications-390571273052\n ","wordCount":"282","inLanguage":"en","datePublished":"2021-10-07T21:48:39Z","dateModified":"2021-10-07T21:48:39Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kocoler.github.io/posts/distribution-system-intor/"},"publisher":{"@type":"Organization","name":"kocoler's blog","logo":{"@type":"ImageObject","url":"https://kocoler.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://kocoler.github.io accesskey=h title="kocoler's blog (Alt + H)">kocoler's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
浅谈分布式
</h1>
<div class=post-meta><span title="2021-10-07 21:48:39 +0000 UTC">October 7, 2021</span>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%88%86%e5%b8%83%e5%bc%8f aria-label=分布式>分布式</a><ul>
<li>
<a href=#why-we-need-distribution-drivens aria-label="Why we need distribution? (drivens)">Why we need distribution? (drivens)</a></li>
<li>
<a href=#distribution aria-label=Distribution>Distribution</a></li>
<li>
<a href=#%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5%e4%b8%8e%e6%8c%87%e6%a0%87 aria-label=一些概念与指标>一些概念与指标</a></li></ul>
</li>
<li>
<a href=#%e5%85%b1%e8%af%86%e6%80%a7%e7%ae%97%e6%b3%95 aria-label=共识性算法>共识性算法</a><ul>
<li>
<a href=#basic-paxos aria-label=(Basic-)Paxos>(Basic-)Paxos</a></li>
<li>
<a href=#raft aria-label=Raft><strong>Raft</strong></a></li></ul>
</li>
<li>
<a href=#%e7%8e%b0%e5%ae%9e%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e5%88%86%e5%b8%83%e5%bc%8f%e7%9a%84 aria-label=现实中是如何设计分布式的>现实中是如何设计分布式的</a><ul>
<li>
<a href=#%e5%a4%9a%e4%b8%bb%e4%b9%8b%e9%97%b4%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=多主之间的一致性：>多主之间的一致性：</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>本文主要科普一下当前比较热门的分布式
<strong>主要涉及 分布式基本概念，共识性算法</strong>
其实说是科普，但是听完你就可以和绝大部分半调子人聊的有来有回了 ~
和别人吹水的时候说：诶，你这个考虑分布式了么，是不是很牛的样子？
虽然我不这么觉得，但是考虑分布式是有必要的 hhh</p>
</blockquote>
<h2 id=分布式>分布式<a hidden class=anchor aria-hidden=true href=#分布式>#</a></h2>
<h3 id=why-we-need-distribution-drivens>Why we need distribution? (drivens)<a hidden class=anchor aria-hidden=true href=#why-we-need-distribution-drivens>#</a></h3>
<p>开始之前我们先来讨论一下我们为什么分布式</p>
<blockquote>
<p>分享结束之后再看一遍这些问题</p>
</blockquote>
<ul>
<li>
<p>性能
如何做到简单的增加服务器就使性能增强（像 GFS 的假设）
这时候我们需要设计一个架构来将这种能力推进下去</p>
</li>
<li>
<p>容错
比如你的两台服务器，挂了一台
如何做到继续可用（当然故障多了就不能用了）
1000台呢（会被无限放大）</p>
</li>
<li>
<p>物理分布
地球这么大，你的数据中心一定会分布到不同的地方</p>
</li>
<li>
<p>安全性
你这个代码他不安全啊，分布式可以做到某一部分是这个代码，并且挂掉并无影响</p>
</li>
</ul>
<h3 id=distribution>Distribution<a hidden class=anchor aria-hidden=true href=#distribution>#</a></h3>
<blockquote>
<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。</p>
</blockquote>
<p>其实分布式很简单，就是多台机子，部署在不同的地方，通过网络通信（大部分都是 RPC）协作</p>
<p>但是我们需要很多额外的策略</p>
<p>因为网络是不稳定的，物理上也是不稳定的，节点（机器）是不稳定的</p>
<p>&mldr;</p>
<p>这些都要考虑到一个分布式系统的设计上</p>
<h3 id=一些概念与指标>一些概念与指标<a hidden class=anchor aria-hidden=true href=#一些概念与指标>#</a></h3>
<ul>
<li>一致性
这个大概就是最重要的了，分布式系统的行为要表现出一致性
<ul>
<li>强一致性
就是说如果 A 在 B 之前请求（避免语义问题，这里是达到服务器），那么 B 得到的结果一定是 A 之后的状态。</li>
<li>弱一致性
弱一致性其实是很拥有的
比如当副本很远的时候可以采取最近节点通信的方式，你可能不会 get 到最新的 key，但是绝大部分场景都是对的，并且有良好的速度，以及低成本（相对强一致性）</li>
</ul>
</li>
<li>可用性
<blockquote>
<p>在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。</p>
</blockquote>
<ul>
<li>容错</li>
<li>自恢复
一个节点 recover 之后需要自恢复，</li>
</ul>
</li>
<li>拓展性（性能）
就是上面说的，一样</li>
</ul>
<p>指标</p>
<ul>
<li>
<p><strong>CAP</strong>
我们会更倾向于用 CAP 去划分一个分布式系统</p>
<blockquote>
<p>CAP 问题就是在出现分区问题的时候，是选择一致性还是可用性</p>
</blockquote>
<ul>
<li>
<p>一致性
同上</p>
</li>
<li>
<p>可用性
可用性一般有两个意义：</p>
<ul>
<li>一个是普遍意义上的可用性，即容错和自恢复</li>
<li>另外一个是指对于每一次请求，都能够得到一个及时的、非错的响应，但是其实是不保证请求的结果是基于最新写入的数据。
CAP 理论指的是后一个，这也是为什么大部分分布式系统都是 CP 或者 AP</li>
</ul>
<blockquote>
<p>但其实 DDIA 中并不建议使用这玩意，但是现在大家说的还都是这个吧 hhhh
据说更精确的是 Consistency, Availability, and Convergence
<a href=https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2036.pdf>https://apps.cs.utexas.edu/tech_reports/reports/tr/TR-2036.pdf</a>
但是咱也没看这篇呢，咱也不细说</p>
</blockquote>
</li>
<li>
<p>分区容错性
基本指的是网络层面被划成若干个区情况下的容错性
为了避免混乱，说明一下其实这个玩意，就是容错，我们一般不会把他与正常的故障分开讨论，但是这里是 CAP 的 P</p>
</li>
</ul>
<p>这个 CAP 其实也经过了漫长的演变</p>
<blockquote>
<p>ch: <a href=https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/>https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/</a>
ori: <a href=https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/>https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/</a></p>
</blockquote>
</li>
<li>
<p>FLP
FLP 不可能原理</p>
<blockquote>
<p>《Impossibility of Distributed Consensus with One Faulty Process》指出：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法</p>
</blockquote>
<p>注意这里是异步的（这个其实在这次分享里不是很重要，在这里我们主要讨论同步调用，但是是分布式基本概念）</p>
</li>
<li>
<p>BASE
BASE 理论主要是针对分布式场景下数据库
应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<ul>
<li>基本可用
允许损失部分可用性，即保证核心可用。
降级服务</li>
<li>软状态
允许中间状态
扩大来说就是允许副本之间时延</li>
<li>最终一致性
经过一段时间一定是一致的状态</li>
</ul>
</li>
</ul>
<p>很简单很简单，我们看看共识性算法，就流程来说也很简单~</p>
<h2 id=共识性算法>共识性算法<a hidden class=anchor aria-hidden=true href=#共识性算法>#</a></h2>
<p>共识性算法算是分布式中最重要的一部分，在这一部分，我们可以对上面很多挑战做出解答
当我们讨论分布式的时候，应该把他和共识性算法分开来看待
当然他也很复杂（实现层面）
这里就是简单的让大家看一下他们是如何设计的（流程上）
当然不会涉及到太多的具体的 specs</p>
<blockquote>
<p>通常只在每个分区内维持顺序，这意味着它们不能提供跨分区的一致性保证（例如，一致性快照，外键引用）。 跨所有分区的全序是可能的，但需要额外的协调</p>
</blockquote>
<blockquote>
<p>主要是 Paxos 和 Raft，其他<del>我</del>能听到的 VSR 和 Zab</p>
</blockquote>
<h3 id=basic-paxos>(Basic-)Paxos<a hidden class=anchor aria-hidden=true href=#basic-paxos>#</a></h3>
<p>我感觉时间可能会有点长，而且会和 Raft 搞混？所以还是简洁一下就略过吧 hhh
<del>反正绝对没人会让你实现这个</del></p>
<p>角色：</p>
<ul>
<li>client
客户端</li>
<li>acceptor/voters
决议</li>
<li>proposer
提议</li>
<li>learner
就是记录的</li>
</ul>
<p>这个玩意主要分为两个阶段，一个是准备决议，一个是批准</p>
<pre tabindex=0><code class=language-raw data-lang=raw>Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  |
   X--------&gt;|          |  |  |       |  |  Request
   |         X---------&gt;|-&gt;|-&gt;|       |  |  Prepare(1)
   |         |&lt;---------X--X--X       |  |  Promise(1,{Va,Vb,Vc})
   |         X---------&gt;|-&gt;|-&gt;|       |  |  Accept!(1,V)
   |         |&lt;---------X--X--X------&gt;|-&gt;|  Accepted(1,V)
   |&lt;---------------------------------X--X  Response
   |         |          |  |  |       |  |
</code></pre><p>但是这个其实有个缺陷，就是作为理论研究挺好的，但是实际场景就有点尴尬（流量过多），所以有了 Mutil-Paxos。</p>
<h3 id=raft><strong>Raft</strong><a hidden class=anchor aria-hidden=true href=#raft>#</a></h3>
<p>（其实这个才是最初分享的重点，但是我觉得还是分享一个分布式的思想比较有意义，Raft 学完就忘）</p>
<p><del>基本就是解析 <a href=https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf>raft-extended c1 - c5(c7)</a></del> 不，我不配，而且不太适合做分享，太细致了</p>
<p>这个出现就是说，因为 Paxos 太难懂了
就但是这个其实也没那么简单</p>
<p>他主要分为几个部分：</p>
<ul>
<li>Leader 选举（leader election）
随机时间</li>
<li>日志（log replication）</li>
<li>安全（safety）
这里的安全主要是指如何安全的保证日志的一致性</li>
</ul>
<p>这里我们只介绍一下 Leader 选举和最基本的如何保证一致性（没那么多复杂状态）好了</p>
<blockquote>
<p><a href=http://thesecretlivesofdata.com/raft/#replication>http://thesecretlivesofdata.com/raft/#replication</a></p>
</blockquote>
<h2 id=现实中是如何设计分布式的>现实中是如何设计分布式的<a hidden class=anchor aria-hidden=true href=#现实中是如何设计分布式的>#</a></h2>
<p><del>这个涉及的太多了，等我学完再说吧</del></p>
<p>就大概那样吧，不同策略结合，现场说吧</p>
<p>数据中心，分片（Map-Reduce）</p>
<p>不断屏蔽下一层设计（以 kv-db 为例：client -> data-center(k8s/swarm multi-master) -> db-nodes(raft &mldr;) -> storage(gfs/hdfs/<a href=https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36971.pdf>megastore</a> &mldr;) -> &mldr; ）</p>
<p>当然不同的设计是不一样的</p>
<h3 id=多主之间的一致性>多主之间的一致性：<a hidden class=anchor aria-hidden=true href=#多主之间的一致性>#</a></h3>
<p><img loading=lazy src=https://i.loli.net/2021/10/15/fXpYzOQnoxAdjDN.png alt="图 2">
</p>
<p>很复杂咯，但是主要问题就是： <strong>复制 + 解决冲突</strong></p>
<p>拓扑复制：</p>
<p><img loading=lazy src=https://i.loli.net/2021/10/15/6Fm9kbVjIXhyliS.png alt="图 3">
</p>
<p>主要就是处理写入冲突，毕竟是给大家分享，这里举个大家都听过的最简单的方法：UUID 最后写入胜利(LWW)
<del>其他：Conflict-free replicated datatypes、Mergeable persistent data structures、Operational transformation 都需要具体实现</del></p>
<p>你们可能会见到的：两阶段提交（2PC）</p>
<p>当然这些还只是入门，分布式坑很大，很值得思考，很值得去寻找解决方案</p>
<p>refs:</p>
<blockquote>
<p><a href=https://en.wikipedia.org/wiki/Paxos_(computer_science)>https://en.wikipedia.org/wiki/Paxos_(computer_science)</a>
<a href=https://stackoverflow.com/questions/25230005/leader-address-location-in-raft>https://stackoverflow.com/questions/25230005/leader-address-location-in-raft</a>
<a href=https://vonng.gitbooks.io/ddia-cn>https://vonng.gitbooks.io/ddia-cn</a></p>
</blockquote>
<blockquote>
<p>Chubby: <a href=https://medium.com/coinmonks/chubby-a-centralized-lock-service-for-distributed-applications-390571273052>https://medium.com/coinmonks/chubby-a-centralized-lock-service-for-distributed-applications-390571273052</a></p>
</blockquote>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://kocoler.github.io>kocoler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>