<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>简述Elasticsearch 7.x | kocoler's blog</title>
<meta name=keywords content>
<meta name=description content="主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比 1. Luence 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎 Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。 简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。
更多有关Luence：
https://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0 https://lucene.apache.org/core/ Luence的全文索引
2. Solar & ES 2.1 Solar Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。
在ES发布之前搜索引擎就是Solar的天下
Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。
2.2 ES 通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
2.3 比较 1.ES开箱即用 2.ES自带分布式协调管理 3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式 4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用 ES建立索引快（即查询慢），即实时性查询快 3. ES 7.x 3.1 ES 的好朋友们 众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着
ELK-Stack(elastic stack)
Logstash：数据收集，处理和储存
Elasticsearch：检索和分析
Kibana：可视化
Beats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 &ndash;> Logstash （建立在名为libbeat的Go框架之上">
<meta name=author content>
<link rel=canonical href=https://kocoler.github.io/posts/es/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kocoler.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://kocoler.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://kocoler.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://kocoler.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://kocoler.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="简述Elasticsearch 7.x">
<meta property="og:description" content="主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比 1. Luence 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎 Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。 简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。
更多有关Luence：
https://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0 https://lucene.apache.org/core/ Luence的全文索引
2. Solar & ES 2.1 Solar Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。
在ES发布之前搜索引擎就是Solar的天下
Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。
2.2 ES 通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
2.3 比较 1.ES开箱即用 2.ES自带分布式协调管理 3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式 4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用 ES建立索引快（即查询慢），即实时性查询快 3. ES 7.x 3.1 ES 的好朋友们 众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着
ELK-Stack(elastic stack)
Logstash：数据收集，处理和储存
Elasticsearch：检索和分析
Kibana：可视化
Beats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 &ndash;> Logstash （建立在名为libbeat的Go框架之上">
<meta property="og:type" content="article">
<meta property="og:url" content="https://kocoler.github.io/posts/es/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-05-30T21:48:39+00:00">
<meta property="article:modified_time" content="2020-05-30T21:48:39+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="简述Elasticsearch 7.x">
<meta name=twitter:description content="主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比 1. Luence 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎 Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。 简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。
更多有关Luence：
https://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0 https://lucene.apache.org/core/ Luence的全文索引
2. Solar & ES 2.1 Solar Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。
在ES发布之前搜索引擎就是Solar的天下
Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。
2.2 ES 通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
2.3 比较 1.ES开箱即用 2.ES自带分布式协调管理 3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式 4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用 ES建立索引快（即查询慢），即实时性查询快 3. ES 7.x 3.1 ES 的好朋友们 众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着
ELK-Stack(elastic stack)
Logstash：数据收集，处理和储存
Elasticsearch：检索和分析
Kibana：可视化
Beats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 &ndash;> Logstash （建立在名为libbeat的Go框架之上">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kocoler.github.io/posts/"},{"@type":"ListItem","position":3,"name":"简述Elasticsearch 7.x","item":"https://kocoler.github.io/posts/es/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"简述Elasticsearch 7.x","name":"简述Elasticsearch 7.x","description":"主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比 1. Luence 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎 Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。 简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。\n更多有关Luence：\nhttps://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0 https://lucene.apache.org/core/ Luence的全文索引\n2. Solar \u0026amp; ES 2.1 Solar Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。\n在ES发布之前搜索引擎就是Solar的天下\nSolr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。\n2.2 ES 通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n2.3 比较 1.ES开箱即用 2.ES自带分布式协调管理 3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式 4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用 ES建立索引快（即查询慢），即实时性查询快 3. ES 7.x 3.1 ES 的好朋友们 众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着\nELK-Stack(elastic stack)\nLogstash：数据收集，处理和储存\nElasticsearch：检索和分析\nKibana：可视化\nBeats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 \u0026ndash;\u0026gt; Logstash （建立在名为libbeat的Go框架之上","keywords":[],"articleBody":"主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比 1. Luence 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎 Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。 简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。\n更多有关Luence：\nhttps://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0 https://lucene.apache.org/core/ Luence的全文索引\n2. Solar \u0026 ES 2.1 Solar Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。\n在ES发布之前搜索引擎就是Solar的天下\nSolr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。\n2.2 ES 通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n2.3 比较 1.ES开箱即用 2.ES自带分布式协调管理 3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式 4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用 ES建立索引快（即查询慢），即实时性查询快 3. ES 7.x 3.1 ES 的好朋友们 众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着\nELK-Stack(elastic stack)\nLogstash：数据收集，处理和储存\nElasticsearch：检索和分析\nKibana：可视化\nBeats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 – Logstash （建立在名为libbeat的Go框架之上\n  elasticsearch head\nelasticsearch head 算是一个轻量级的管理器\n  7.0版本支持SQL（X-Pack）\n3.2 ES 7.x 3.2.1 前情提要（上次所讲到的，和一些没有讲到的但是是基础的）\nES是一个分布式搜索引擎，底层使用Lucene来实现其核心搜索功能，所使用的是NoSQL（not only SQL)\n核心：全文索引\n全文索引\n更适用于非结构化数据 （格式和长度不固定的数据），传统数据库查询效率很低\n倒排索引\n倒排索引会先对文档进行分析将其拆分成单个Term, 并存储包含该Term的文档id\n这样的倒排索引建立起来会导致索引的大小迅速膨胀，对此引入了一个特殊的数据结构叫FST（有限状态转换器） ES使用了索引帧（Frame of Reference）技术压缩posting list\n然后是ES的基本概念：\n  Index: 索引\n集合，类比DB\n  Type:\n“_doc”\n最近版本取消自定义\n  Document: 文档\n记录\n  Field：字段\n某一属性\n  库（database）索引（index）表（table）类型（type）行（row）文档（doc）列（column）字段（field） 类型\ncore datatypes: string:text/keyword numeric:long, integer……….\ncomplex datatypes\ngro datatypes\nspecialised datatypes: ip, rank feature\nhttps://www.elastic.co/guide/en/elasticsearch/reference/7.7/mapping-types.html   mapping(索引模板)：\n两个创建途径：\na. 当放入的数据不属于当前Type中任何一个的时候会自动创建\nb.通过settings mappings 来创建\n通过mapping和setting可以设置很多属性：\nstore: 是否存储 analyzer: 分词器，默认是standard analyzer boost: 增加该字段的权重 format: 设置输出格式（日期） https://www.elastic.co/guide/en/elasticsearch/reference/7.7/mapping-params.html   聚合：\n类比pipiline\n  refresh：\n刷新时间间隔\ndefault：1s\n  translog：\n当一个文档写入Lucence后是存储在内存中的，即使执行了refresh操作仍然是在文件系统缓存中，如果此时服务器宕机，那么这部分数据将会丢失。为此ES增加了translog， 当进行文档写操作时会先将文档写入Lucene，然后写入一份到translog，写入translog是落盘的。可以设置成异步存储。\n  flush：\n每30分钟或当translog达到一定大小，ES会触发一次flush操作，此时ES会先执行refresh操作将buffer中的数据生成segment，然后调用lucene的commit方法将所有内存中的segment fsync到磁盘。此时lucene中的数据就完成了持久化。\n  fliter:\n过滤\nfilter语句采用了Roaring Bitmap技术来缓存搜索结果，保证高频filter查询速度的同时降低存储空间消耗。\n  score:\n默认情况下，Elasticsearch按相关性得分对匹配的搜索结果进行排序，该得分衡量每个文档与查询的匹配程度。\n  分片与备份：\n分布式设计：为了支持对海量数据的存储和查询，Elasticsearch引入分片的概念，一个索引被分成多个分片，每个分片可以有一个主分片和多个副本分片，每个分片副本都是一个具有完整功能的lucene实例，可以独立进行存储和搜索。分片可以分配在不同的节点上，同一个分片的不同副本不能分配在相同的节点上。\nElasticsearch的早期版本默认为每个索引创建五个分片。从7.0.0开始，默认值为每个索引一个分片。\n在进行读写操作时，ES会先计算出文档要所在或要分配到的分片，再从集群元数据中找出对应主分片的位置\n  更多的基本概念：https://www.elastic.co/guide/en/elasticsearch/reference/7.7/glossary.html 3.3 ES 使用 3.3.1 插件\nES插件有很多，这里只介绍一个。\n更多的时候我们需要通过聚合不同的插件来达到我们的目的，这也是ES极其强大的原因之一\n ik pinyin  ik是一款用于es的中文分词器插件\npinyin是一款用于es拼音形式的插件\n3.3.2 Restful格式下的使用\n  写入\nhttps://cloud.tencent.com/developer/article/1531723   查询\n  GET /s1/_search { \"query\": { \"match_all\": {} } } #手动创建settings与mappings #不可覆盖 PUT /s1/#_settings { \"settings\": { \"number_of_shards\": 1, \"number_of_replicas\": 0 }, \"mappings\": { \"properties\": { \"first\": {\"type\": \"text\", \"analyzer\": \"ik_max_word\"}, \"last\": {\"type\": \"text\", \"store\": false} } } } #_bulk 批量操作 #自定义添加/修改 PUT /e1/word/1 { \"first\": \"wo\", \"next\": \"ww\" } POST /e1/word/ { \"f\": \"q\", \"n\": \"w\" } PUT /s1/_bulk {\"index\":{\"_id\":\"1\"}} {\"first\": \"世界\",\"last\": \"中国\"} {\"index\":{\"_id\":\"2\"}} {\"first\": \"华师\",\"last\": \"木犀\"} {\"index\":{\"_id\":\"3\"}} {\"first\": \"我爱中国\",\"last\": \"中国\"} {\"index\":{\"_id\":\"4\"}} {\"first\": \"世界\",\"last\": \"美国\"} {\"index\":{\"_id\":\"5\"}} {\"first\": \"世界\",\"last\": \"英国\"} {\"index\":{\"_id\":\"6\"}} {\"first\": \"我爱中国\",\"last\": \"中国\",\"ex\":\"我\"} #获取配置 GET /e1/_settings GET /e2/_settings GET /e1/_mapping #所有的类型设置 GET _all/_settings #获取 GET /e1/word/2?_source=n # 通过_version和version_type=external 进行版本控制 #基本查询 GET /e1/_search?q=first:wo #ik 全文查询match GET /s1/_search { \"version\": true, \"from\": 0, \"size\": 2, \"_source\": { \"includes\": \"fir*\", \"excludes\": \"w\" }, \"query\": { \"match\": { \"first\": \"我\" } } } #query:\"我\" #fields:[\"first\",\"last\"] #range: \"fields\":\"from\":,\"to\": #sort #wildcard: 可用\"*/?\" #fuzzy: 模糊查询 #filter: 过滤上下文 # ik + pinyin GET /test8/_settings GET /test8/_mapping GET /_analyze { \"analyzer\":\"pinyin\", \"text\":\"我爱中华人民共和国\" } PUT /test8/_doc/3 { \"content\": \"我爱华师\" } PUT /test8/_doc/4 { \"content\": \"中国武汉\" } PUT /test8/_doc/5 { \"content\": \"武汉在中国\" } GET /test8/_search { \"query\": { \"match\": { \"content\": { \"query\": \"zg\" } } } } 如何自制分析器： https://www.elastic.co/guide/en/elasticsearch/reference/7.7/analysis-custom-analyzer.html 3.4 ES 与 Go ES虽然很早就出现了，但是最先写Go语言使用ES的一些接口框架的并不是官方，所以事实上另一个第三方包更火一点（星星数），并且作者也在积极的维护，功能完备\n这两个包分别是 olivere/elastic 和 elastic/go-elasticsearch\n这里主要介绍olivere/elastic这个第三方包具体使用情况和grom挺相似的\n一些示例代码\n算了，直接看官方的吧：https://olivere.github.io/elastic/\n参考链接\nhttps://www.elastic.co/cn/logstash https://www.cnblogs.com/blueskyli/p/8326229.html https://cloud.tencent.com/developer/article/1543565 https://zhuanlan.zhihu.com/p/137574234 https://www.cnblogs.com/LQBlog/p/10449637.html ","wordCount":"391","inLanguage":"en","datePublished":"2020-05-30T21:48:39Z","dateModified":"2020-05-30T21:48:39Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kocoler.github.io/posts/es/"},"publisher":{"@type":"Organization","name":"kocoler's blog","logo":{"@type":"ImageObject","url":"https://kocoler.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://kocoler.github.io accesskey=h title="kocoler's blog (Alt + H)">kocoler's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
简述Elasticsearch 7.x
</h1>
<div class=post-meta><span title="2020-05-30 21:48:39 +0000 UTC">May 30, 2020</span>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#1-luence aria-label="1. Luence">1. Luence</a></li>
<li>
<a href=#2-solar--es aria-label="2. Solar &amp;amp; ES">2. Solar & ES</a><ul>
<li>
<a href=#21-solar aria-label="2.1 Solar">2.1 Solar</a></li>
<li>
<a href=#22-es aria-label="2.2 ES">2.2 ES</a></li>
<li>
<a href=#23-%e6%af%94%e8%be%83 aria-label="2.3 比较">2.3 比较</a></li></ul>
</li>
<li>
<a href=#3-es-7x aria-label="3. ES 7.x">3. ES 7.x</a><ul>
<li>
<a href=#31-es-%e7%9a%84%e5%a5%bd%e6%9c%8b%e5%8f%8b%e4%bb%ac aria-label="3.1 ES 的好朋友们">3.1 ES 的好朋友们</a></li>
<li>
<a href=#32-es-7x aria-label="3.2 ES 7.x">3.2 ES 7.x</a></li>
<li>
<a href=#33-es-%e4%bd%bf%e7%94%a8 aria-label="3.3 ES 使用">3.3 ES 使用</a></li>
<li>
<a href=#34-es-%e4%b8%8e-go aria-label="3.4 ES 与 Go">3.4 ES 与 Go</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><pre tabindex=0><code>主要讲述ES 7.x 版本的东西，附带同样基于Luence并且很火的Solar和ES的对比
</code></pre><h3 id=1-luence>1. Luence<a hidden class=anchor aria-hidden=true href=#1-luence>#</a></h3>
<pre tabindex=0><code>是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎
Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。
</code></pre><p>简而言之：Lucene是apache下的一个开源的全文检索引擎工具包。</p>
<p>更多有关Luence：</p>
<pre tabindex=0><code>https://tool.oschina.net/apidocs/apidoc?api=lucene-3.6.0

https://lucene.apache.org/core/
</code></pre><p><strong>Luence的全文索引</strong></p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/Luence.webp alt>
</p>
<h3 id=2-solar--es>2. Solar & ES<a hidden class=anchor aria-hidden=true href=#2-solar--es>#</a></h3>
<h4 id=21-solar>2.1 Solar<a hidden class=anchor aria-hidden=true href=#21-solar>#</a></h4>
<p>Solr 作为 Apache 基金会的顶级项目，技术成熟而且用户量巨大。</p>
<p>在ES发布之前搜索引擎就是Solar的天下</p>
<p>Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。</p>
<h4 id=22-es>2.2 ES<a hidden class=anchor aria-hidden=true href=#22-es>#</a></h4>
<p>通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h4 id=23-比较>2.3 比较<a hidden class=anchor aria-hidden=true href=#23-比较>#</a></h4>
<pre tabindex=0><code>1.ES开箱即用
2.ES自带分布式协调管理
3.Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式

4.Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用
  ES建立索引快（即查询慢），即实时性查询快
</code></pre><h3 id=3-es-7x>3. ES 7.x<a hidden class=anchor aria-hidden=true href=#3-es-7x>#</a></h3>
<h4 id=31-es-的好朋友们>3.1 ES 的好朋友们<a hidden class=anchor aria-hidden=true href=#31-es-的好朋友们>#</a></h4>
<p>众所周知，大家都喜欢看有UI的东西，ES也具有很完备的WebUI，并且在积极的维护着</p>
<p><strong>ELK-Stack</strong>(elastic stack)</p>
<p>Logstash：数据收集，处理和储存</p>
<p>Elasticsearch：检索和分析</p>
<p>Kibana：可视化</p>
<p>Beats：轻量级（资源高效，无依赖性，小型）的日志发送程序。收集数据 &ndash;> Logstash （建立在名为libbeat的Go框架之上</p>
<ul>
<li>
<p><strong>elasticsearch head</strong></p>
<p>elasticsearch head 算是一个轻量级的管理器</p>
</li>
</ul>
<p>7.0版本支持SQL（X-Pack）</p>
<h4 id=32-es-7x>3.2 ES 7.x<a hidden class=anchor aria-hidden=true href=#32-es-7x>#</a></h4>
<p><strong>3.2.1 前情提要</strong>（上次所讲到的，和一些没有讲到的但是是基础的）</p>
<p>ES是一个分布式搜索引擎，底层使用Lucene来实现其核心搜索功能，所使用的是NoSQL（not only SQL)</p>
<p>核心：全文索引</p>
<p><strong>全文索引</strong></p>
<p>更适用于非结构化数据 （格式和长度不固定的数据），传统数据库查询效率很低</p>
<p>倒排索引</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%951.png alt>
</p>
<p>倒排索引会先对文档进行分析将其拆分成单个Term, 并存储包含该Term的文档id</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%952.png alt>
</p>
<p>这样的倒排索引建立起来会导致索引的大小迅速膨胀，对此引入了一个特殊的数据结构叫FST（有限状态转换器）
ES使用了索引帧（Frame of Reference）技术压缩posting list</p>
<p>然后是ES的基本概念：</p>
<ul>
<li>
<p>Index: 索引</p>
<p>集合，类比DB</p>
</li>
<li>
<p>Type:</p>
<p>&ldquo;_doc&rdquo;</p>
<p>最近版本取消自定义</p>
</li>
<li>
<p>Document: 文档</p>
<p>记录</p>
</li>
<li>
<p>Field：字段</p>
<p>某一属性</p>
</li>
</ul>
<pre tabindex=0><code>库（database）索引（index）表（table）类型（type）行（row）文档（doc）列（column）字段（field）
</code></pre><p>类型</p>
<p>core datatypes: string:text/keyword numeric:long, integer&mldr;&mldr;&mldr;.</p>
<p>complex datatypes</p>
<p>gro datatypes</p>
<p>specialised datatypes: ip, rank feature</p>
<pre tabindex=0><code>https://www.elastic.co/guide/en/elasticsearch/reference/7.7/mapping-types.html
</code></pre><ul>
<li>
<p>mapping(索引模板)：</p>
<p>两个创建途径：</p>
<p>a. 当放入的数据不属于当前Type中任何一个的时候会自动创建</p>
<p>b.通过<code>settings</code> <code>mappings</code> 来创建</p>
<p>通过mapping和setting可以设置很多属性：</p>
<pre tabindex=0><code>store: 是否存储
analyzer: 分词器，默认是standard analyzer
boost: 增加该字段的权重
format: 设置输出格式（日期）

https://www.elastic.co/guide/en/elasticsearch/reference/7.7/mapping-params.html
</code></pre></li>
<li>
<p>聚合：</p>
<p>类比pipiline</p>
</li>
<li>
<p>refresh：</p>
<p>刷新时间间隔</p>
<p>default：1s</p>
</li>
<li>
<p>translog：</p>
<p>当一个文档写入Lucence后是存储在内存中的，即使执行了refresh操作仍然是在文件系统缓存中，如果此时服务器宕机，那么这部分数据将会丢失。为此ES增加了translog， 当进行文档写操作时会先将文档写入Lucene，然后写入一份到translog，写入translog是落盘的。可以设置成异步存储。</p>
</li>
<li>
<p>flush：</p>
<p>每30分钟或当translog达到一定大小，ES会触发一次flush操作，此时ES会先执行refresh操作将buffer中的数据生成segment，然后调用lucene的commit方法将所有内存中的segment fsync到磁盘。此时lucene中的数据就完成了持久化。</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/flush.png alt>
</p>
</li>
<li>
<p>fliter:</p>
<p>过滤</p>
<p>filter语句采用了Roaring Bitmap技术来缓存搜索结果，保证高频filter查询速度的同时降低存储空间消耗。</p>
</li>
<li>
<p>score:</p>
<p>默认情况下，Elasticsearch按相关性得分对匹配的搜索结果进行排序，该得分衡量每个文档与查询的匹配程度。</p>
</li>
<li>
<p>分片与备份：</p>
<p>分布式设计：为了支持对海量数据的存储和查询，Elasticsearch引入分片的概念，一个索引被分成多个分片，每个分片可以有一个主分片和多个副本分片，每个分片副本都是一个具有完整功能的lucene实例，可以独立进行存储和搜索。分片可以分配在不同的节点上，同一个分片的不同副本不能分配在相同的节点上。</p>
<p>Elasticsearch的早期版本默认为每个索引创建五个分片。从7.0.0开始，默认值为每个索引一个分片。</p>
<p>在进行读写操作时，ES会先计算出文档要所在或要分配到的分片，再从集群元数据中找出对应主分片的位置</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%89%AF%E6%9C%AC.jpg alt>
</p>
</li>
</ul>
<pre tabindex=0><code>更多的基本概念：https://www.elastic.co/guide/en/elasticsearch/reference/7.7/glossary.html
</code></pre><h4 id=33-es-使用>3.3 ES 使用<a hidden class=anchor aria-hidden=true href=#33-es-使用>#</a></h4>
<p><strong>3.3.1 插件</strong></p>
<p>ES插件有很多，这里只介绍一个。</p>
<p>更多的时候我们需要通过聚合不同的插件来达到我们的目的，这也是ES极其强大的原因之一</p>
<ul>
<li>ik</li>
<li>pinyin</li>
</ul>
<p>ik是一款用于es的中文分词器插件</p>
<p>pinyin是一款用于es拼音形式的插件</p>
<p><strong>3.3.2 Restful格式下的使用</strong></p>
<ul>
<li>
<p>写入</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.jpg alt>
</p>
<pre tabindex=0><code>https://cloud.tencent.com/developer/article/1531723
</code></pre></li>
<li>
<p>查询</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/kocoler/Notes-Pic/master/sharing/%E6%9F%A5%E8%AF%A2.png alt>
</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ae81ff>GET /s1/_search</span>
{
  <span style=color:#f92672>&#34;query&#34;: </span>{
    <span style=color:#f92672>&#34;match_all&#34;: </span>{}
  }
}

<span style=color:#75715e>#手动创建settings与mappings</span>
<span style=color:#75715e>#不可覆盖</span>
<span style=color:#ae81ff>PUT /s1/#_settings</span>
{
  <span style=color:#f92672>&#34;settings&#34;: </span>{
    <span style=color:#f92672>&#34;number_of_shards&#34;: </span><span style=color:#ae81ff>1</span>,
    <span style=color:#f92672>&#34;number_of_replicas&#34;: </span><span style=color:#ae81ff>0</span>
  },
  <span style=color:#f92672>&#34;mappings&#34;: </span>{
    <span style=color:#f92672>&#34;properties&#34;: </span>{
      <span style=color:#f92672>&#34;first&#34;: {&#34;type&#34;: &#34;text&#34;, &#34;analyzer&#34;: </span><span style=color:#e6db74>&#34;ik_max_word&#34;</span>},
      <span style=color:#f92672>&#34;last&#34;: {&#34;type&#34;: &#34;text&#34;, &#34;store&#34;: </span><span style=color:#66d9ef>false</span>}
    }
  }
}

<span style=color:#75715e>#_bulk 批量操作</span>

<span style=color:#75715e>#自定义添加/修改</span>
<span style=color:#ae81ff>PUT /e1/word/1</span>
{
  <span style=color:#f92672>&#34;first&#34;: </span><span style=color:#e6db74>&#34;wo&#34;</span>,
  <span style=color:#f92672>&#34;next&#34;: </span><span style=color:#e6db74>&#34;ww&#34;</span>
}

<span style=color:#ae81ff>POST /e1/word/</span>
{
  <span style=color:#f92672>&#34;f&#34;: </span><span style=color:#e6db74>&#34;q&#34;</span>,
  <span style=color:#f92672>&#34;n&#34;: </span><span style=color:#e6db74>&#34;w&#34;</span>
}

<span style=color:#ae81ff>PUT /s1/_bulk</span>
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;1&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;世界&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;中国&#34;</span>}
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;2&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;华师&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;木犀&#34;</span>}
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;3&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;我爱中国&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;中国&#34;</span>}
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;4&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;世界&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;美国&#34;</span>}
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;5&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;世界&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;英国&#34;</span>}
{<span style=color:#e6db74>&#34;index&#34;</span>:{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#e6db74>&#34;6&#34;</span>}}
{<span style=color:#f92672>&#34;first&#34;: &#34;我爱中国&#34;,&#34;last&#34;: </span><span style=color:#e6db74>&#34;中国&#34;</span>,<span style=color:#e6db74>&#34;ex&#34;</span>:<span style=color:#e6db74>&#34;我&#34;</span>}

<span style=color:#75715e>#获取配置</span>
<span style=color:#ae81ff>GET /e1/_settings</span>
<span style=color:#ae81ff>GET /e2/_settings</span>
<span style=color:#ae81ff>GET /e1/_mapping</span>

<span style=color:#75715e>#所有的类型设置</span>
<span style=color:#ae81ff>GET _all/_settings</span>

<span style=color:#75715e>#获取</span>
<span style=color:#ae81ff>GET /e1/word/2?_source=n</span>

<span style=color:#75715e># 通过_version和version_type=external 进行版本控制</span>

<span style=color:#75715e>#基本查询</span>
<span style=color:#ae81ff>GET /e1/_search?q=first:wo</span>

<span style=color:#75715e>#ik 全文查询match</span>
<span style=color:#ae81ff>GET /s1/_search</span>
{
  <span style=color:#f92672>&#34;version&#34;: </span><span style=color:#66d9ef>true</span>,
  <span style=color:#f92672>&#34;from&#34;: </span><span style=color:#ae81ff>0</span>,
  <span style=color:#f92672>&#34;size&#34;: </span><span style=color:#ae81ff>2</span>,
  <span style=color:#f92672>&#34;_source&#34;: </span>{
    <span style=color:#f92672>&#34;includes&#34;: </span><span style=color:#e6db74>&#34;fir*&#34;</span>,
    <span style=color:#f92672>&#34;excludes&#34;: </span><span style=color:#e6db74>&#34;w&#34;</span>
  },
  <span style=color:#f92672>&#34;query&#34;: </span>{
    <span style=color:#f92672>&#34;match&#34;: </span>{
      <span style=color:#f92672>&#34;first&#34;: </span><span style=color:#e6db74>&#34;我&#34;</span>
    }
  }
}
<span style=color:#75715e>#query:&#34;我&#34;</span>
<span style=color:#75715e>#fields:[&#34;first&#34;,&#34;last&#34;]</span>
<span style=color:#75715e>#range: &#34;fields&#34;:&#34;from&#34;:,&#34;to&#34;:</span>
<span style=color:#75715e>#sort</span>
<span style=color:#75715e>#wildcard: 可用&#34;*/?&#34;</span>
<span style=color:#75715e>#fuzzy: 模糊查询</span>
<span style=color:#75715e>#filter: 过滤上下文</span>

<span style=color:#75715e># ik + pinyin</span>
<span style=color:#ae81ff>GET /test8/_settings</span>
<span style=color:#ae81ff>GET /test8/_mapping</span>

<span style=color:#ae81ff>GET /_analyze</span>
{
  <span style=color:#e6db74>&#34;analyzer&#34;</span>:<span style=color:#e6db74>&#34;pinyin&#34;</span>,
  <span style=color:#e6db74>&#34;text&#34;</span>:<span style=color:#e6db74>&#34;我爱中华人民共和国&#34;</span>
}

<span style=color:#ae81ff>PUT /test8/_doc/3</span>
{
  <span style=color:#f92672>&#34;content&#34;: </span><span style=color:#e6db74>&#34;我爱华师&#34;</span>
}

<span style=color:#ae81ff>PUT /test8/_doc/4</span>
{
  <span style=color:#f92672>&#34;content&#34;: </span><span style=color:#e6db74>&#34;中国武汉&#34;</span>
}

<span style=color:#ae81ff>PUT /test8/_doc/5</span>
{
  <span style=color:#f92672>&#34;content&#34;: </span><span style=color:#e6db74>&#34;武汉在中国&#34;</span>
}


<span style=color:#ae81ff>GET /test8/_search</span>
{
  <span style=color:#f92672>&#34;query&#34;: </span>{
    <span style=color:#f92672>&#34;match&#34;: </span>{
      <span style=color:#f92672>&#34;content&#34;: </span>{
        <span style=color:#f92672>&#34;query&#34;: </span><span style=color:#e6db74>&#34;zg&#34;</span>
      }
    }
  }
}


</code></pre></div><pre tabindex=0><code>如何自制分析器：
https://www.elastic.co/guide/en/elasticsearch/reference/7.7/analysis-custom-analyzer.html
</code></pre><h4 id=34-es-与-go>3.4 ES 与 Go<a hidden class=anchor aria-hidden=true href=#34-es-与-go>#</a></h4>
<p>ES虽然很早就出现了，但是最先写Go语言使用ES的一些接口框架的并不是官方，所以事实上另一个第三方包更火一点（星星数），并且作者也在积极的维护，功能完备</p>
<p>这两个包分别是 <strong><a href=https://github.com/olivere/elastic>olivere/elastic</a></strong> 和 <strong><a href=https://github.com/elastic/go-elasticsearch>elastic/go-elasticsearch</a></strong></p>
<p>这里主要介绍olivere/elastic这个第三方包具体使用情况和grom挺相似的</p>
<p>一些示例代码</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
</code></pre></div><p>算了，直接看官方的吧：https://olivere.github.io/elastic/</p>
<p>参考链接</p>
<pre tabindex=0><code>https://www.elastic.co/cn/logstash
https://www.cnblogs.com/blueskyli/p/8326229.html
https://cloud.tencent.com/developer/article/1543565
https://zhuanlan.zhihu.com/p/137574234
https://www.cnblogs.com/LQBlog/p/10449637.html
</code></pre>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on twitter" href="https://twitter.com/intent/tweet/?text=%e7%ae%80%e8%bf%b0Elasticsearch%207.x&url=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f&title=%e7%ae%80%e8%bf%b0Elasticsearch%207.x&summary=%e7%ae%80%e8%bf%b0Elasticsearch%207.x&source=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f&title=%e7%ae%80%e8%bf%b0Elasticsearch%207.x"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on whatsapp" href="https://api.whatsapp.com/send?text=%e7%ae%80%e8%bf%b0Elasticsearch%207.x%20-%20https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 简述Elasticsearch 7.x on telegram" href="https://telegram.me/share/url?text=%e7%ae%80%e8%bf%b0Elasticsearch%207.x&url=https%3a%2f%2fkocoler.github.io%2fposts%2fes%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://kocoler.github.io>kocoler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>