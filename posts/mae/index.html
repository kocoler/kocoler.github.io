<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>MAE + MKE 设计 | kocoler's blog</title>
<meta name=keywords content>
<meta name=description content="MAE(MUXI APP ENGINE) 主要分为两个部分：
 基础业务 集群管理   对应 Github 上的 specs Github 上为英文版本
  因为历史原因，项目基本结构并不是 DDD 但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因 部分设计参考阿里成熟的开源项目 kubevela 项目代码清晰，符合普遍的社区标准 但是目前还未开源&mldr; 此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq
 技术选用:
 Mysql 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB Mysql, Gorm 作为 orm 框架 Redis 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis Client-go 管理集群是本项目核心部分，目前团队基本所有服务都部署与 k3s(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK Gin 为本项目的 Web 框架  重点：
 关于集群管理 关于分布式场景下一致性的讨论  至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的
基础业务 用户系统 最基本的用户系统，以及鉴权 接入团队 OAuth2.">
<meta name=author content>
<link rel=canonical href=https://kocoler.github.io/posts/mae/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kocoler.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://kocoler.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://kocoler.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://kocoler.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://kocoler.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="MAE + MKE 设计">
<meta property="og:description" content="MAE(MUXI APP ENGINE) 主要分为两个部分：
 基础业务 集群管理   对应 Github 上的 specs Github 上为英文版本
  因为历史原因，项目基本结构并不是 DDD 但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因 部分设计参考阿里成熟的开源项目 kubevela 项目代码清晰，符合普遍的社区标准 但是目前还未开源&mldr; 此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq
 技术选用:
 Mysql 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB Mysql, Gorm 作为 orm 框架 Redis 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis Client-go 管理集群是本项目核心部分，目前团队基本所有服务都部署与 k3s(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK Gin 为本项目的 Web 框架  重点：
 关于集群管理 关于分布式场景下一致性的讨论  至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的
基础业务 用户系统 最基本的用户系统，以及鉴权 接入团队 OAuth2.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://kocoler.github.io/posts/mae/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-06-29T21:48:39+00:00">
<meta property="article:modified_time" content="2021-06-29T21:48:39+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="MAE + MKE 设计">
<meta name=twitter:description content="MAE(MUXI APP ENGINE) 主要分为两个部分：
 基础业务 集群管理   对应 Github 上的 specs Github 上为英文版本
  因为历史原因，项目基本结构并不是 DDD 但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因 部分设计参考阿里成熟的开源项目 kubevela 项目代码清晰，符合普遍的社区标准 但是目前还未开源&mldr; 此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq
 技术选用:
 Mysql 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB Mysql, Gorm 作为 orm 框架 Redis 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis Client-go 管理集群是本项目核心部分，目前团队基本所有服务都部署与 k3s(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK Gin 为本项目的 Web 框架  重点：
 关于集群管理 关于分布式场景下一致性的讨论  至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的
基础业务 用户系统 最基本的用户系统，以及鉴权 接入团队 OAuth2.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kocoler.github.io/posts/"},{"@type":"ListItem","position":3,"name":"MAE + MKE 设计","item":"https://kocoler.github.io/posts/mae/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MAE + MKE 设计","name":"MAE \u002b MKE 设计","description":"MAE(MUXI APP ENGINE) 主要分为两个部分：\n 基础业务 集群管理   对应 Github 上的 specs Github 上为英文版本\n  因为历史原因，项目基本结构并不是 DDD 但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因 部分设计参考阿里成熟的开源项目 kubevela 项目代码清晰，符合普遍的社区标准 但是目前还未开源\u0026hellip; 此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq\n 技术选用:\n Mysql 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB Mysql, Gorm 作为 orm 框架 Redis 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis Client-go 管理集群是本项目核心部分，目前团队基本所有服务都部署与 k3s(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK Gin 为本项目的 Web 框架  重点：\n 关于集群管理 关于分布式场景下一致性的讨论  至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的\n基础业务 用户系统 最基本的用户系统，以及鉴权 接入团队 OAuth2.","keywords":[],"articleBody":"MAE(MUXI APP ENGINE) 主要分为两个部分：\n 基础业务 集群管理   对应 Github 上的 specs Github 上为英文版本\n  因为历史原因，项目基本结构并不是 DDD 但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因 部分设计参考阿里成熟的开源项目 kubevela 项目代码清晰，符合普遍的社区标准 但是目前还未开源… 此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq\n 技术选用:\n Mysql 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB Mysql, Gorm 作为 orm 框架 Redis 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis Client-go 管理集群是本项目核心部分，目前团队基本所有服务都部署与 k3s(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK Gin 为本项目的 Web 框架  重点：\n 关于集群管理 关于分布式场景下一致性的讨论  至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的\n基础业务 用户系统 最基本的用户系统，以及鉴权 接入团队 OAuth2.0 接口，设计实现 OAuth Interface，符合规范，便于接入其他的 OAuth 认证平台\n黑名单在服务启动时从 Mysql 数据库 Fan-out 到 Redis 缓存，便于后期使用 黑名单部分作为 协程(goroutinue) 加快项目启动时初始化的速度 可以考虑将 Redis 部分做成布隆过滤器，但是项目目前使用人数较少，未启用\n组织系统 用户可以成为相应组织的成员，组织是根据团队内的应用划分(application) 的 主要用途：\n 同时 application 也用于划分 k8s 集群上的 Namespace 用于隔离不同的 application 的资源 用于在不同操作时进行 RBAC 鉴权控制  服务管理(部署) 首先需要指出的概念是，当我们考虑一个服务的时候，他可能需要有若干\n每一个服务都属于一个应用(因为基本都是微服务，以及一些单体小服务，都适用于服务的概念)\n传统的部署方法：创建 NS(如果没有) - 创建 Ingress(附带 SSL 相关资源) - 创建 Deployment - 创建 Service\n这里将 Deployment 和 Service 聚合在一起，只给用户暴露一个 服务(Service) 的概念 还有一个 Ingress 路由的概念，其余与 k8s 交互及逻辑部分内部实现\n用户可以 自定义模板(template) (通过 text/template 解析后，绑定到 k8s resource 的各个参数)用于生成部署在服务器上的资源\n具有有默认模板，适用于大部分业务\n并且将通用配置的统一出来，填表部署(填充必须字段)\n子模块：\n 部署记录，也根据路由和服务分为两个部分 特定的 ID 记录用于 回滚 特定版本(集群粒度的控制)，并且 实时（after refresh status） 显示每个部署的服务在集群上的状态 至于为什么需要用户手动刷新或者刷新页面，减少服务器负载，如果什么都用最极致的，那肯定 websocket 了，但是太重了，也不需要 也可以 setInterval 1s 定时刷新  部署状态 这里将在集群上的状态简化为以下四种： 部署中，已停止，部署成功，部署失败\n我们都知道 k8s 的资源是需要创建的，其中 Ingress, Service, Namespce, Deployment 的创建结果都是会同步被 api-server 返回的，那么我们可以假设，如果他创建成功，那么他就是成功的了 事实上，如果我们忽略运维人为删除，那么这个状态就是可以保证的，将状态写入到数据库进行持久化 而 Deployment 下面的 RS, node 则较为复杂，下文也会讨论到\n那么我们可以很方便的将部署状态分为两部分：创建时状态和运行时状态\n 创建时状态 这里主要考虑的是 Ingress, Service, Namespace, Deployment 的直接创建结果 如果还未触发  服务器、集群   服务器 因为团队所需的服务器也不是很少，因此需要单一的服务器记录系统 业务需要记录服务器的各种配置信息以及过期信息 到期前若干天触发过期提示\n设计是：用户创建 RAM 用户(阿里云概念，可以是其他信息) - RAM 自动导入服务器信息\n抽象 ECS Interface 用于从服务商导入服务器\n  集群\n目前采用的方式是使用集群内 ServiceAccount 的 Token + CA 证书，用于访问集群内的服务(一个集群一个)\n关于集群部分的权限控制需要在集群上改动其权限，从 MAE 中剥离开来，这也是初始化集群的时候应该做的（目前手动，可以考虑 bash 脚本自动 scp 到本地然后走 api 上传）\n  流水线(CI pipeline) 关于团队自建的 Drone CI ，需要将 Build 部分接入到 基础业务 中 设计 CI Interface，用于兼容不同 CI 的 SDK 主要用于将服务的部署部分都集成到一起(用户通过 push gitea 的 tag 触发 drone ci 的 trigger，最后 MAE 一键部署)\n通知系统 具体的通知分发业务后迁移至 MUMS 项目 主要涉及 服务器到期，服务部署状态提示 等\n指标(metrics) 只做服务内各指标监控 暴露出用于监控该服务的内部信息，暴露到 Prometheus，然后接入 Grafana 监控整个服务情况 Tracing 部分正在完善中，可以更好的掌握服务性能等\n集群管理(Cluster Management) 概览 MKE(MUXI K8s Engine) 是独立于 MAE 存在的与 k8s api server 交互的，自己封装 libary(大概算是)\n  MKE with client-go\nMKE 内嵌于 MAE 中的部分 通过 k8s 官方的 SDK client-go 与目标 集群上的 api-server 交互 这一部分主要这几了最基本的(也是业务需要的) 创建，更新，删除 等等功能\n  MKE CRD\n因为单纯使用 clinet-go 与集群交互对于一些监控状态操作不是那么直接(如：Deployment 的具体状态，同时涉及 Deployment 与 ReplicaSet) 并且在测试场景遇到了一些 BUG(已经忘了是什么了，好像是在 服务重启是会重复触发事件) 于是直接选择了最开始就想的集群 CRD 方案，让这一部分作为 CRD 运行在各个集群上去帮助我们得知 Deployemnt 的状态，反馈回来\n还有一个原因就是，我们的 MAE 与 集群 交互是走公网的，因为可能会与不同的集群不在同一个地域，所以也要尽可能的减少与集群间的网络流量，并且学生机性能并不好，尤其要减少单个服务器的处理任务（均摊）\n  详细资源 接下来是根据 k8s 中我们需要用到的具体的资源\nNamespace Namespace 作为 K8s 中最直接的隔离资源的概念，非常适合对应到我们业务中的 Application\n  新的 Application\n先根据 Application 的 name(符合 RFC 规定的) 在所有的集群上创建 Namespace\n  新的 Cluster\n根据所有存在的 Application 在新的集群上创建 Namespace\n  这样就保证了所有的 Application 在不同集群上的迁移部署等等（因为这里的集群对所有的服务都是可用的，所以是所有的集群，如果涉及到其他粒度的控制问题，则需要再加详细的控制逻辑）\nIngress Ingress 作为内部服务暴露到集群与外界交互的一部分，需要用户自定义每个 Route 的细节，并且可以引入 SSL\n  创建流程：\n新的 Ingress 资源 - 在目标集群上 Apply - 如果有错误，直接 Callback\n  如何收集目标集群\n因为这里的集群分为 Test 和 Product 两种，每次的部署需要同时考虑这两种 对应关系为： ns - services, ns - ingresses, service - clusters = ingresses - clusters\n  同时，所有的 Ingress 资源在集群中由 name(version) 来区分 Ingress 的 更新，创建，新版本发布，在不同的 版本之间是分开的，但是在不同的集群（生产/测试）上是可以不同的\nService + Deployment = version 讲 K8s 中的 Service 和 Deployment 组合在一起，形成本项目中的 版本（version） 的概念，也就是向用户暴露的概念，用户的所有操作都是对 version 的操作，其中的信息也是直接编写对应 version 的 service template\n  状态\n分为两个部分：\n 部署（deploying）到集群上的状态 已经在集群上的状态 Pending，Success 或者 Failed 并且把这些日志集成到对应部署记录的日志中，通过特定的部署记录访问相关的部署日志    流程\n关系：一个版本对应多个资源对应多个集群 one version - multiple resources – multiple clusters\n on the cluster: new deployment - replicaset(s) - pod(s)\n new version - apply on target clusters(service \u0026\u0026 deployment) -\n  service\n因为 service 也是只涉及一个单独的创建资源过程，所以这里采用的方法是直接 callback 触发相关流程，也不需要重试等等\n  deployment\n之前的设计:\n goto deploymentStatusWatcher - replicasetsWacher - podWacher - callback  现在的设计: 对于创建资源状态阶段 是可以直接 callback 的 对于在集群上的具体状态是要通过 deploymentWatcher 会报来的状态更新\n    具有默认模板给用户使用\n一些讨论 Callback 很明显，各种因素（主要是响应时间），导致了这里的所有与 集群 的交互过程基本都是异步的\n所以这里使用了 Callback 机制来完成所有的异步回调，更新状态机状态\n场景举例：\n  创建资源 只需要用 MKE 封装的 apply 方法进行创建资源操作，将结果处理函数 这样将 MKE 与 MAE 完全解耦，使得 MAE 某一个资源的后续操作完全自由控制，MKE 只负责回调\n如图： CallBack 的 Interface 设计\n  持久化 作为保障一致性最有效的手段就是持久化 每一部分关于资源的一些状态，都需要持久化，并且需要一些策略来保证每个事件对每个状态机的影响，同时需要保证每次交互的 幂等性\n为什么把 deployment-operater 剥离出来 上文讨论过具体的思考 同时也是为了方便后面更多的 CRD 资源出现\n配套组件 MUMS MUMS(Muxi Unify Message System)\n用于统一目前可用的 飞书、钉钉 等第三方消息推送服务 用于推送到团队此基础平台的各种通知消息\n目前已有：feishu-bot 用于推送 ci 的构建结果\n… TO BE CONTINUE\n","wordCount":"526","inLanguage":"en","datePublished":"2021-06-29T21:48:39Z","dateModified":"2021-06-29T21:48:39Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kocoler.github.io/posts/mae/"},"publisher":{"@type":"Organization","name":"kocoler's blog","logo":{"@type":"ImageObject","url":"https://kocoler.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://kocoler.github.io accesskey=h title="kocoler's blog (Alt + H)">kocoler's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
MAE + MKE 设计
</h1>
<div class=post-meta><span title="2021-06-29 21:48:39 +0000 UTC">June 29, 2021</span>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%9f%ba%e7%a1%80%e4%b8%9a%e5%8a%a1 aria-label=基础业务>基础业务</a><ul>
<li>
<a href=#%e7%94%a8%e6%88%b7%e7%b3%bb%e7%bb%9f aria-label=用户系统>用户系统</a></li>
<li>
<a href=#%e7%bb%84%e7%bb%87%e7%b3%bb%e7%bb%9f aria-label=组织系统>组织系统</a></li>
<li>
<a href=#%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86%e9%83%a8%e7%bd%b2 aria-label=服务管理(部署)><strong>服务管理(部署)</strong></a><ul>
<li>
<a href=#%e9%83%a8%e7%bd%b2%e7%8a%b6%e6%80%81 aria-label=部署状态><strong>部署状态</strong></a></li></ul>
</li>
<li>
<a href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%9b%86%e7%be%a4 aria-label=服务器、集群>服务器、集群</a></li>
<li>
<a href=#%e6%b5%81%e6%b0%b4%e7%ba%bfci-pipeline aria-label="流水线(CI pipeline)">流水线(CI pipeline)</a></li>
<li>
<a href=#%e9%80%9a%e7%9f%a5%e7%b3%bb%e7%bb%9f aria-label=通知系统>通知系统</a></li>
<li>
<a href=#%e6%8c%87%e6%a0%87metrics aria-label=指标(metrics)>指标(metrics)</a></li></ul>
</li>
<li>
<a href=#%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86cluster-management aria-label="集群管理(Cluster Management)">集群管理(Cluster Management)</a><ul>
<li>
<a href=#%e6%a6%82%e8%a7%88 aria-label=概览>概览</a></li>
<li>
<a href=#%e8%af%a6%e7%bb%86%e8%b5%84%e6%ba%90 aria-label=详细资源>详细资源</a><ul>
<li>
<a href=#namespace aria-label=Namespace>Namespace</a></li>
<li>
<a href=#ingress aria-label=Ingress>Ingress</a></li>
<li>
<a href=#service--deployment--version aria-label="Service + Deployment =&amp;gt; version">Service + Deployment => version</a></li></ul>
</li></ul>
</li>
<li>
<a href=#%e4%b8%80%e4%ba%9b%e8%ae%a8%e8%ae%ba aria-label=一些讨论>一些讨论</a><ul>
<li>
<a href=#callback aria-label=Callback>Callback</a></li>
<li>
<a href=#%e6%8c%81%e4%b9%85%e5%8c%96 aria-label=持久化>持久化</a></li>
<li>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%8a%8a-deployment-operater-%e5%89%a5%e7%a6%bb%e5%87%ba%e6%9d%a5 aria-label="为什么把 deployment-operater 剥离出来">为什么把 deployment-operater 剥离出来</a></li>
<li>
<a href=#%e9%85%8d%e5%a5%97%e7%bb%84%e4%bb%b6 aria-label=配套组件>配套组件</a><ul>
<li>
<a href=#mums aria-label=MUMS>MUMS</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>MAE(MUXI APP ENGINE) 主要分为两个部分：</p>
<ul>
<li>基础业务</li>
<li>集群管理</li>
</ul>
<blockquote>
<p>对应 Github 上的 specs
Github 上为英文版本</p>
</blockquote>
<blockquote>
<p>因为历史原因，项目基本结构并不是 DDD
但是大部分分包也是比较清晰的，虽然并不指望有人维护，这也是代码里要更多考虑 自恢复/差错容忍/其他人为外部运维因素 的原因
部分设计参考阿里成熟的开源项目 kubevela
项目代码清晰，符合普遍的社区标准
但是目前还未开源&mldr;
此介绍文档还在不断更新，如果更新了设计，以及我想更新哈哈哈qwq</p>
</blockquote>
<p>技术选用:</p>
<ul>
<li><code>Mysql</code> 因为本项目大部分数据的数据模型都是关系模型，所以选用了较为熟悉的 RDB <code>Mysql</code>, <code>Gorm</code> 作为 <code>orm</code> 框架</li>
<li><code>Redis</code> 本项目需要最基本的 业务层缓存 以及 轻量消息队列作为缓冲，所以选用了较为熟悉的 Redis</li>
<li><code>Client-go</code> 管理集群是本项目核心部分，目前团队基本所有服务都部署与 <code>k3s</code>(更轻量的 k8s，减少服务器负载) 管理的集群上，所以选用 client-go 作为项目与集群的交互的 k8s SDK</li>
<li><code>Gin</code> 为本项目的 Web 框架</li>
</ul>
<p><strong>重点</strong>：</p>
<ul>
<li>关于集群管理</li>
<li>关于分布式场景下一致性的讨论</li>
</ul>
<p>至于为什么会涉及到分布式场景，作为一个基于 k8s 上的服务，不天然支持分布式不太好对不对 hhh，也许是过度设计，但是考虑这些是十分有必要的</p>
<h3 id=基础业务>基础业务<a hidden class=anchor aria-hidden=true href=#基础业务>#</a></h3>
<h4 id=用户系统>用户系统<a hidden class=anchor aria-hidden=true href=#用户系统>#</a></h4>
<p>最基本的用户系统，以及鉴权
接入团队 OAuth2.0 接口，设计实现 <strong>OAuth Interface</strong>，符合规范，便于接入其他的 OAuth 认证平台</p>
<p>黑名单在服务启动时从 Mysql 数据库 <strong>Fan-out</strong> 到 Redis 缓存，便于后期使用
黑名单部分作为 协程(goroutinue) 加快项目启动时初始化的速度
可以考虑将 Redis 部分做成布隆过滤器，但是项目目前使用人数较少，未启用</p>
<h4 id=组织系统>组织系统<a hidden class=anchor aria-hidden=true href=#组织系统>#</a></h4>
<p>用户可以成为相应组织的成员，组织是根据团队内的应用划分(application) 的
主要用途：</p>
<ul>
<li>同时 application 也用于划分 k8s 集群上的 Namespace</li>
<li>用于隔离不同的 application 的资源</li>
<li>用于在不同操作时进行 <strong>RBAC</strong> 鉴权控制</li>
</ul>
<h4 id=服务管理部署><strong>服务管理(部署)</strong><a hidden class=anchor aria-hidden=true href=#服务管理部署>#</a></h4>
<p>首先需要指出的概念是，当我们考虑一个服务的时候，他可能需要有若干</p>
<p>每一个服务都属于一个应用(因为基本都是微服务，以及一些单体小服务，都适用于服务的概念)</p>
<p>传统的部署方法：创建 NS(如果没有) -> 创建 Ingress(附带 SSL 相关资源) -> 创建 Deployment -> 创建 Service</p>
<p>这里将 Deployment 和 Service 聚合在一起，只给用户暴露一个 服务(Service) 的概念
还有一个 Ingress 路由的概念，其余与 k8s 交互及逻辑部分内部实现</p>
<p>用户可以 <strong>自定义模板(template)</strong> (通过 text/template 解析后，绑定到 k8s resource 的各个参数)用于生成部署在服务器上的资源</p>
<p>具有有默认模板，适用于大部分业务</p>
<p>并且将通用配置的统一出来，填表部署(填充必须字段)</p>
<p>子模块：</p>
<ul>
<li>部署记录，也根据路由和服务分为两个部分
特定的 ID 记录用于 <strong>回滚</strong> 特定版本(集群粒度的控制)，并且 <em>实时（after refresh status）</em> 显示每个部署的服务在集群上的状态
至于为什么需要用户手动刷新或者刷新页面，减少服务器负载，如果什么都用最极致的，那肯定 websocket 了，但是太重了，也不需要
也可以 setInterval 1s 定时刷新</li>
</ul>
<h5 id=部署状态><strong>部署状态</strong><a hidden class=anchor aria-hidden=true href=#部署状态>#</a></h5>
<p>这里将在集群上的状态简化为以下四种：
部署中，已停止，部署成功，部署失败</p>
<p>我们都知道 k8s 的资源是需要创建的，其中 Ingress, Service, Namespce, Deployment 的创建结果都是会同步被 api-server 返回的，那么我们可以假设，如果他创建成功，那么他就是成功的了
事实上，如果我们忽略运维人为删除，那么这个状态就是可以保证的，将状态写入到数据库进行持久化
而 Deployment 下面的 RS, node 则较为复杂，下文也会讨论到</p>
<p>那么我们可以很方便的将部署状态分为两部分：创建时状态和运行时状态</p>
<ul>
<li>创建时状态
这里主要考虑的是 Ingress, Service, Namespace, Deployment 的直接创建结果
如果还未触发</li>
</ul>
<h4 id=服务器集群>服务器、集群<a hidden class=anchor aria-hidden=true href=#服务器集群>#</a></h4>
<ul>
<li>
<p>服务器
因为团队所需的服务器也不是很少，因此需要单一的服务器记录系统
业务需要记录服务器的各种配置信息以及过期信息
到期前若干天触发过期提示</p>
<p>设计是：用户创建 RAM 用户(阿里云概念，可以是其他信息) -> RAM 自动导入服务器信息</p>
<p>抽象 <strong>ECS Interface</strong> 用于从服务商导入服务器</p>
</li>
<li>
<p>集群</p>
<p>目前采用的方式是使用集群内 ServiceAccount 的 Token + CA 证书，用于访问集群内的服务(一个集群一个)</p>
<p>关于集群部分的权限控制需要在集群上改动其权限，从 MAE 中剥离开来，这也是初始化集群的时候应该做的（目前手动，可以考虑 bash 脚本自动 scp 到本地然后走 api 上传）</p>
</li>
</ul>
<h4 id=流水线ci-pipeline>流水线(CI pipeline)<a hidden class=anchor aria-hidden=true href=#流水线ci-pipeline>#</a></h4>
<p>关于团队自建的 Drone CI ，需要将 Build 部分接入到 基础业务 中
设计 <strong>CI Interface</strong>，用于兼容不同 CI 的 SDK
主要用于将服务的部署部分都集成到一起(用户通过 push gitea 的 tag 触发 drone ci 的 trigger，最后 MAE 一键部署)</p>
<h4 id=通知系统>通知系统<a hidden class=anchor aria-hidden=true href=#通知系统>#</a></h4>
<p>具体的通知分发业务后迁移至 MUMS 项目
主要涉及 服务器到期，服务部署状态提示 等</p>
<h4 id=指标metrics>指标(metrics)<a hidden class=anchor aria-hidden=true href=#指标metrics>#</a></h4>
<p>只做服务内各指标监控
暴露出用于监控该服务的内部信息，暴露到 Prometheus，然后接入 Grafana 监控整个服务情况
Tracing 部分正在完善中，可以更好的掌握服务性能等</p>
<h3 id=集群管理cluster-management>集群管理(Cluster Management)<a hidden class=anchor aria-hidden=true href=#集群管理cluster-management>#</a></h3>
<h4 id=概览>概览<a hidden class=anchor aria-hidden=true href=#概览>#</a></h4>
<p>MKE(MUXI K8s Engine) 是独立于 MAE 存在的与 k8s api server 交互的，自己封装 libary(大概算是)</p>
<ul>
<li>
<p><strong>MKE with client-go</strong></p>
<p>MKE 内嵌于 MAE 中的部分
通过 k8s 官方的 SDK client-go 与目标 集群上的 api-server 交互
这一部分主要这几了最基本的(也是业务需要的) 创建，更新，删除 等等功能</p>
</li>
<li>
<p><strong>MKE CRD</strong></p>
<p>因为单纯使用 clinet-go 与集群交互对于一些监控状态操作不是那么直接(如：Deployment 的具体状态，同时涉及 Deployment 与 ReplicaSet)
并且在测试场景遇到了一些 BUG(已经忘了是什么了，好像是在 服务重启是会重复触发事件) 于是直接选择了最开始就想的集群 CRD 方案，让这一部分作为 CRD 运行在各个集群上去帮助我们得知 Deployemnt 的状态，反馈回来</p>
<p>还有一个原因就是，我们的 MAE 与 集群 交互是走公网的，因为可能会与不同的集群不在同一个地域，所以也要尽可能的<strong>减少与集群间的网络流量</strong>，并且学生机性能并不好，尤其要<strong>减少单个服务器的处理任务</strong>（均摊）</p>
</li>
</ul>
<h4 id=详细资源>详细资源<a hidden class=anchor aria-hidden=true href=#详细资源>#</a></h4>
<p>接下来是根据 k8s 中我们需要用到的具体的资源</p>
<h5 id=namespace>Namespace<a hidden class=anchor aria-hidden=true href=#namespace>#</a></h5>
<p>Namespace 作为 K8s 中最直接的隔离资源的概念，非常适合对应到我们业务中的 Application</p>
<ul>
<li>
<p>新的 Application</p>
<p>先根据 Application 的 name(符合 RFC 规定的) 在<strong>所有</strong>的集群上创建 Namespace</p>
</li>
<li>
<p>新的 Cluster</p>
<p>根据<strong>所有</strong>存在的 Application 在新的集群上创建 Namespace</p>
</li>
</ul>
<p>这样就保证了所有的 Application 在不同集群上的迁移部署等等（因为这里的集群对所有的服务都是可用的，所以是所有的集群，如果涉及到其他粒度的控制问题，则需要再加详细的控制逻辑）</p>
<h5 id=ingress>Ingress<a hidden class=anchor aria-hidden=true href=#ingress>#</a></h5>
<p>Ingress 作为内部服务暴露到集群与外界交互的一部分，需要用户自定义每个 Route 的细节，并且可以引入 SSL</p>
<ul>
<li>
<p>创建流程：</p>
<p>新的 Ingress 资源 -> 在目标集群上 Apply -> 如果有错误，直接 Callback</p>
</li>
<li>
<p>如何收集目标集群</p>
<p>因为这里的集群分为 Test 和 Product 两种，每次的部署需要同时考虑这两种
对应关系为：
ns -> services, ns -> ingresses, service -> clusters
=>
ingresses -> clusters</p>
</li>
</ul>
<p>同时，所有的 Ingress 资源在集群中由 name(version) 来区分
Ingress 的 更新，创建，新版本发布，在不同的 版本之间是分开的，但是在不同的集群（生产/测试）上是可以不同的</p>
<h5 id=service--deployment--version>Service + Deployment => version<a hidden class=anchor aria-hidden=true href=#service--deployment--version>#</a></h5>
<p>讲 K8s 中的 Service 和 Deployment 组合在一起，形成本项目中的 版本（version） 的概念，也就是向用户暴露的概念，用户的所有操作都是对 version 的操作，其中的信息也是直接编写对应 version 的 service template</p>
<ul>
<li>
<p>状态</p>
<p>分为两个部分：</p>
<ul>
<li>部署（deploying）到集群上的状态</li>
<li>已经在集群上的状态
Pending，Success 或者 Failed
并且把这些日志集成到对应部署记录的日志中，通过特定的部署记录访问相关的部署日志</li>
</ul>
</li>
<li>
<p>流程</p>
<p>关系：一个版本对应多个资源对应多个集群
one version -> multiple resources &ndash;> multiple clusters</p>
<blockquote>
<p>on the cluster: new deployment -> replicaset(s) -> pod(s)</p>
</blockquote>
<p>new version -> apply on target clusters(service && deployment) -></p>
<ul>
<li>
<p>service</p>
<p>因为 service 也是只涉及一个单独的创建资源过程，所以这里采用的方法是直接 callback 触发相关流程，也不需要重试等等</p>
</li>
<li>
<p>deployment</p>
<p>之前的设计:</p>
<pre><code>  goto deploymentStatusWatcher -&gt; replicasetsWacher -&gt; podWacher -&gt; callback
</code></pre>
<p>现在的设计:
对于创建资源状态阶段 是可以直接 callback 的
对于在集群上的具体状态是要通过 deploymentWatcher 会报来的状态更新</p>
</li>
</ul>
</li>
</ul>
<p>具有默认模板给用户使用</p>
<h3 id=一些讨论>一些讨论<a hidden class=anchor aria-hidden=true href=#一些讨论>#</a></h3>
<h4 id=callback>Callback<a hidden class=anchor aria-hidden=true href=#callback>#</a></h4>
<p>很明显，各种因素（主要是响应时间），导致了这里的所有与 集群 的交互过程基本都是异步的</p>
<p>所以这里使用了 Callback 机制来完成所有的异步回调，更新状态机状态</p>
<p>场景举例：</p>
<ul>
<li>
<p>创建资源
只需要用 MKE 封装的 apply 方法进行创建资源操作，将结果处理函数
这样将 MKE 与 MAE 完全解耦，使得 MAE 某一个资源的后续操作完全自由控制，MKE 只负责回调</p>
<p>如图：
<img loading=lazy src=https://s2.loli.net/2021/12/14/IKJUkWreLyOG3Ec.png alt="图 1">
<br>
CallBack 的 Interface 设计</p>
</li>
</ul>
<h4 id=持久化>持久化<a hidden class=anchor aria-hidden=true href=#持久化>#</a></h4>
<p>作为保障一致性最有效的手段就是持久化
每一部分关于资源的一些状态，都需要持久化，并且需要一些策略来保证每个事件对每个状态机的影响，同时需要保证每次交互的 幂等性</p>
<h4 id=为什么把-deployment-operater-剥离出来>为什么把 deployment-operater 剥离出来<a hidden class=anchor aria-hidden=true href=#为什么把-deployment-operater-剥离出来>#</a></h4>
<p>上文讨论过具体的思考
同时也是为了方便后面更多的 CRD 资源出现</p>
<h4 id=配套组件>配套组件<a hidden class=anchor aria-hidden=true href=#配套组件>#</a></h4>
<h5 id=mums>MUMS<a hidden class=anchor aria-hidden=true href=#mums>#</a></h5>
<p>MUMS(Muxi Unify Message System)</p>
<p>用于统一目前可用的 飞书、钉钉 等第三方消息推送服务
用于推送到团队此基础平台的各种通知消息</p>
<p>目前已有：feishu-bot 用于推送 ci 的构建结果</p>
<p>&mldr;
TO BE CONTINUE</p>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on twitter" href="https://twitter.com/intent/tweet/?text=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1&url=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f&title=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1&summary=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1&source=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f&title=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on whatsapp" href="https://api.whatsapp.com/send?text=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1%20-%20https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share MAE + MKE 设计 on telegram" href="https://telegram.me/share/url?text=MAE%20%2b%20MKE%20%e8%ae%be%e8%ae%a1&url=https%3a%2f%2fkocoler.github.io%2fposts%2fmae%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://kocoler.github.io>kocoler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>